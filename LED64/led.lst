
led.elf:     file format elf32-msp430

SYMBOL TABLE:
00004000 l    d  .text	00000000 .text
00004a0e l    d  .rodata	00000000 .rodata
00001100 l    d  .data	00000000 .data
00001130 l    d  .noinit	00000000 .noinit
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 LED64.c
00004a0e l     O .rodata	00000010 MixColMatrix
00004a1e l     O .rodata	00000010 sbox
00004a2e l     O .rodata	00000010 invMixColMatrix
00004a3e l     O .rodata	00000010 invSbox
000040fc l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 tools.c
00000000 l    df *ABS*	00000000 memcpy.c
000048da g     F .text	0000001a putchar
00000057 g       *ABS*	00000000 __BCSCTL1
0000005a g       *ABS*	00000000 __CACTL2
00000174 g       *ABS*	00000000 __TACCR1
00000084 g       *ABS*	00000000 __ADC12MCTL4
00000030 g       *ABS*	00000000 __data_size
0000015a g       *ABS*	00000000 __ADC12MEM13
00000052 g       *ABS*	00000000 __I2CNDAT
000040fc  w      .text	00000000 __isr_14
00000128 g       *ABS*	00000000 __FCTL1
00000024 g       *ABS*	00000000 __P1IES
0000007b g       *ABS*	00000000 __U1MCTL
000001f6 g       *ABS*	00000000 __DMA2SZ
000040fc  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
00000076 g       *ABS*	00000000 __I2CDRW
0000007e g       *ABS*	00000000 __U1RXBUF
00000138 g       *ABS*	00000000 __OP2
00000076 g       *ABS*	00000000 __U0RXBUF
000001a4 g       *ABS*	00000000 __ADC12IFG
0000012e g       *ABS*	00000000 __TAIV
000001e6 g       *ABS*	00000000 __DMA0SZ
00000000 g       .vectors	00000000 _efartext
0000007c g       *ABS*	00000000 __U1BR0
00000130 g       *ABS*	00000000 __MPY
00000001 g       *ABS*	00000000 __IE2
0000013a g       *ABS*	00000000 __RESLO
00000136 g       *ABS*	00000000 __MACS
00000087 g       *ABS*	00000000 __ADC12MCTL7
0000002b g       *ABS*	00000000 __P2IFG
0000001a g       *ABS*	00000000 __P3DIR
00004a4e g       *ABS*	00000000 _etext
00000190 g       *ABS*	00000000 __TBR
0000001d g       *ABS*	00000000 __P4OUT
000001f4 g       *ABS*	00000000 __DMA2DA
00000000 g       *ABS*	00000000 __bss_size
00000081 g       *ABS*	00000000 __ADC12MCTL1
0000484a g     F .text	0000005e uart1_init
00000152 g       *ABS*	00000000 __ADC12MEM9
00004000  w      .text	00000000 __watchdog_support
000040f6  w      .text	00000000 __stop_progExec__
00004912 g     F .text	000000fa memcpy
00000050 g       *ABS*	00000000 __I2CIE
0000002d g       *ABS*	00000000 __P2IE
000001e4 g       *ABS*	00000000 __DMA0DA
00004484 g     F .text	000000ba MixColumn
00000192 g       *ABS*	00000000 __TBCCR0
000040fc  w      .text	00000000 __isr_11
00000186 g       *ABS*	00000000 __TBCCTL2
00004908 g     F .text	0000000a end_expe
00000025 g       *ABS*	00000000 __P1IE
000001a0 g       *ABS*	00000000 __ADC12CTL0
00000072 g       *ABS*	00000000 __I2CDCTL
00000073 g       *ABS*	00000000 __U0MCTL
0000007a g       *ABS*	00000000 __U1RCTL
00000082 g       *ABS*	00000000 __ADC12MCTL2
0000019c g       *ABS*	00000000 __TBCCR5
00000035 g       *ABS*	00000000 __P6OUT
000046c8 g     F .text	000000ba invMixColumn
00000034 g       *ABS*	00000000 __P6IN
000001c8 g       *ABS*	00000000 __DAC12_0DAT
00000182 g       *ABS*	00000000 __TBCCTL0
0000019e g       *ABS*	00000000 __TBCCR6
000040fc  w      .text	00000000 __isr_5
00004a4e g       *ABS*	00000000 __data_load_start
000040fc g       .text	00000000 __dtors_end
000001ea g       *ABS*	00000000 __DMA1SA
00000088 g       *ABS*	00000000 __ADC12MCTL8
00000166 g       *ABS*	00000000 __TACCTL2
000001f0 g       *ABS*	00000000 __DMA2CTL
000040fc  w      .text	00000000 __isr_2
00000156 g       *ABS*	00000000 __ADC12MEM11
00000160 g       *ABS*	00000000 __TACTL
00000158 g       *ABS*	00000000 __ADC12MEM12
00000071 g       *ABS*	00000000 __I2CTCTL
0000012c g       *ABS*	00000000 __FCTL3
000040fc  w      .text	00000000 __isr_10
00000148 g       *ABS*	00000000 __ADC12MEM4
0000011a g       *ABS*	00000000 __I2CSA
0000002e g       *ABS*	00000000 __P2SEL
00000180 g       *ABS*	00000000 __TBCTL
0000008d g       *ABS*	00000000 __ADC12MCTL13
0000014c g       *ABS*	00000000 __ADC12MEM6
00000023 g       *ABS*	00000000 __P1IFG
0000013c g       *ABS*	00000000 __RESHI
00000072 g       *ABS*	00000000 __U0RCTL
00000172 g       *ABS*	00000000 __TACCR0
00000071 g       *ABS*	00000000 __U0TCTL
000045c4 g     F .text	00000066 invSubCell
00000056 g       *ABS*	00000000 __DCOCTL
00000085 g       *ABS*	00000000 __ADC12MCTL5
00000003 g       *ABS*	00000000 __IFG2
00000005 g       *ABS*	00000000 __ME2
00001130 g     O .noinit	00000002 __wdt_clear_value
00000079 g       *ABS*	00000000 __U1TCTL
0000001b g       *ABS*	00000000 __P3SEL
000001e0 g       *ABS*	00000000 __DMA0CTL
000040fc  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
00000028 g       *ABS*	00000000 __P2IN
0000014e g       *ABS*	00000000 __ADC12MEM7
00000184 g       *ABS*	00000000 __TBCCTL1
0000005b g       *ABS*	00000000 __CAPD
00000075 g       *ABS*	00000000 __I2CSCLL
000040fc  w      .text	00000000 __isr_0
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
0000462a g     F .text	0000009e invShiftRow
00004028  w      .text	00000000 __do_clear_bss
00004190 g     F .text	000000e6 AddKey
0000008f g       *ABS*	00000000 __ADC12MCTL15
00000021 g       *ABS*	00000000 __P1OUT
0000002c g       *ABS*	00000000 __P2IES
0000015c g       *ABS*	00000000 __ADC12MEM14
00004100 g     F .text	00000090 FieldMult
00000026 g       *ABS*	00000000 __P1SEL
00000198 g       *ABS*	00000000 __TBCCR3
00000080 g       *ABS*	00000000 __ADC12MCTL0
00000140 g       *ABS*	00000000 __ADC12MEM0
00004782 g     F .text	0000008a invLEDRound
00000074 g       *ABS*	00000000 __U0BR0
00000051 g       *ABS*	00000000 __I2CIFG
00004a0c  w      .text	00000000 _unexpected_
000040fc  w      .text	00000000 __isr_8
0000014a g       *ABS*	00000000 __ADC12MEM5
00000070 g       *ABS*	00000000 __U0CTL
0000018a g       *ABS*	00000000 __TBCCTL4
00000073 g       *ABS*	00000000 __I2CPSC
0000008e g       *ABS*	00000000 __ADC12MCTL14
000040fc  w      .text	00000000 __isr_3
000001a6 g       *ABS*	00000000 __ADC12IE
000048a8 g     F .text	00000032 uart1_putchar
00000144 g       *ABS*	00000000 __ADC12MEM2
000001ee g       *ABS*	00000000 __DMA1SZ
00000033 g       *ABS*	00000000 __P5SEL
00000030 g       *ABS*	00000000 __P5IN
00004000  w      .text	00000000 _reset_vector__
000040fc g       .text	00000000 __ctors_start
000040fc  w      .text	00000000 __isr_12
00000036 g       *ABS*	00000000 __P6DIR
00000018 g       *ABS*	00000000 __P3IN
00004010  w      .text	00000000 __do_copy_data
00000150 g       *ABS*	00000000 __ADC12MEM8
00000142 g       *ABS*	00000000 __ADC12MEM1
00001130 g       .data	00000000 __bss_start
0000007d g       *ABS*	00000000 __U1BR1
0000403e g     F .text	000000b8 main
00000176 g       *ABS*	00000000 __TACCR2
0000019a g       *ABS*	00000000 __TBCCR4
000040fc  w      .text	00000000 __isr_13
00000078 g       *ABS*	00000000 __U1CTL
000001e2 g       *ABS*	00000000 __DMA0SA
00000170 g       *ABS*	00000000 __TAR
00000124 g       *ABS*	00000000 __DMACTL1
0000001e g       *ABS*	00000000 __P4DIR
000043e8 g     F .text	0000009c ShiftRow
00000162 g       *ABS*	00000000 __TACCTL0
00010000 g       .vectors	00000000 _vectors_end
00000154 g       *ABS*	00000000 __ADC12MEM10
000001f2 g       *ABS*	00000000 __DMA2SA
0000002a g       *ABS*	00000000 __P2DIR
00000089 g       *ABS*	00000000 __ADC12MCTL9
0000008a g       *ABS*	00000000 __ADC12MCTL10
0000480c g     F .text	0000003e delay
00000032 g       *ABS*	00000000 __P5DIR
000001c2 g       *ABS*	00000000 __DAC12_1CTL
000001a2 g       *ABS*	00000000 __ADC12CTL1
000001a8 g       *ABS*	00000000 __ADC12IV
000001e8 g       *ABS*	00000000 __DMA1CTL
00000075 g       *ABS*	00000000 __U0BR1
000040fc  w      .text	00000000 __isr_9
0000018c g       *ABS*	00000000 __TBCCTL5
0000400c  w      .text	00000000 __init_stack
00000086 g       *ABS*	00000000 __ADC12MCTL6
00000188 g       *ABS*	00000000 __TBCCTL3
00000019 g       *ABS*	00000000 __P3OUT
000001ca g       *ABS*	00000000 __DAC12_1DAT
000040fc g       .text	00000000 __dtors_start
000040fc  w      .text	00000000 __isr_6
000040fc g       .text	00000000 __ctors_end
00000132 g       *ABS*	00000000 __MPYS
0000011c g       *ABS*	00000000 __I2CIV
00000004 g       *ABS*	00000000 __ME1
00003900 g       *ABS*	00000000 __stack
00000037 g       *ABS*	00000000 __P6SEL
000040fc  w      .text	00000000 __isr_1
0000008c g       *ABS*	00000000 __ADC12MCTL12
00001130 g       .data	00000000 _edata
00000077 g       *ABS*	00000000 __U0TXBUF
0000453e g     F .text	00000086 LEDRound
00001132 g       *ABS*	00000000 _end
00000194 g       *ABS*	00000000 __TBCCR1
0000011e g       *ABS*	00000000 __TBIV
000001c0 g       *ABS*	00000000 __DAC12_0CTL
000048f4 g     F .text	0000000a start_encrypt
0000015e g       *ABS*	00000000 __ADC12MEM15
00000134 g       *ABS*	00000000 __MAC
00000058 g       *ABS*	00000000 __BCSCTL2
000040f6  w      .text	00000000 _endless_loop__
00000122 g       *ABS*	00000000 __DMACTL0
0000001f g       *ABS*	00000000 __P4SEL
00000196 g       *ABS*	00000000 __TBCCR2
00000022 g       *ABS*	00000000 __P1DIR
00000146 g       *ABS*	00000000 __ADC12MEM3
00000076 g       *ABS*	00000000 __I2CDRB
00000118 g       *ABS*	00000000 __I2COA
00000164 g       *ABS*	00000000 __TACCTL1
0000007f g       *ABS*	00000000 __U1TXBUF
00000055 g       *ABS*	00000000 __SVSCTL
00004010  w      .text	00000000 __low_level_init
000048fe g     F .text	0000000a start_decrypt
00004382 g     F .text	00000066 SubCell
00001100 g       .data	00000000 __data_start
0000018e g       *ABS*	00000000 __TBCCTL6
00000074 g       *ABS*	00000000 __I2CSCLH
000001ec g       *ABS*	00000000 __DMA1DA
00000120 g       *ABS*	00000000 __WDTCTL
00000083 g       *ABS*	00000000 __ADC12MCTL3
00000000 g       *ABS*	00000000 __IE1
00000059 g       *ABS*	00000000 __CACTL1
00000020 g       *ABS*	00000000 __P1IN
0000001c g       *ABS*	00000000 __P4IN
0000008b g       *ABS*	00000000 __ADC12MCTL11
0000013e g       *ABS*	00000000 __SUMEXT
00000031 g       *ABS*	00000000 __P5OUT
00004276 g     F .text	0000010c AddConstants



Disassembly of section .text:

00004000 <__watchdog_support>:
    4000:	55 42 20 01 	mov.b	&0x0120,r5	
    4004:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
    4008:	82 45 30 11 	mov	r5,	&0x1130	

0000400c <__init_stack>:
    400c:	31 40 00 39 	mov	#14592,	r1	;#0x3900

00004010 <__do_copy_data>:
    4010:	3f 40 30 00 	mov	#48,	r15	;#0x0030
    4014:	0f 93       	tst	r15		
    4016:	08 24       	jz	$+18     	;abs 0x4028
    4018:	92 42 30 11 	mov	&0x1130,&0x0120	
    401c:	20 01 
    401e:	2f 83       	decd	r15		
    4020:	9f 4f 4e 4a 	mov	19022(r15),4352(r15);0x4a4e(r15), 0x1100(r15)
    4024:	00 11 
    4026:	f8 23       	jnz	$-14     	;abs 0x4018

00004028 <__do_clear_bss>:
    4028:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    402c:	0f 93       	tst	r15		
    402e:	07 24       	jz	$+16     	;abs 0x403e
    4030:	92 42 30 11 	mov	&0x1130,&0x0120	
    4034:	20 01 
    4036:	1f 83       	dec	r15		
    4038:	cf 43 30 11 	mov.b	#0,	4400(r15);r3 As==00, 0x1130(r15)
    403c:	f9 23       	jnz	$-12     	;abs 0x4030

0000403e <main>:
}

/************************************************************************/

int main(int argc, char*argv[])
{
    403e:	04 41       	mov	r1,	r4	
    4040:	24 53       	incd	r4		
    4042:	31 50 c8 ff 	add	#-56,	r1	;#0xffc8
    4046:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    404a:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	#endif
	u8 state[4][4];
	u8 keys[32];
	int i,j;

	START_ENCRYPT();
    404e:	b0 12 f4 48 	call	#0x48f4	

	for(i = 0; i < 4; i++)
    4052:	84 43 c6 ff 	mov	#0,	-58(r4)	;r3 As==00, 0xffc6(r4)
    4056:	22 3c       	jmp	$+70     	;abs 0x409c
		for(j = 0; j < 4; j++)
    4058:	84 43 c8 ff 	mov	#0,	-56(r4)	;r3 As==00, 0xffc8(r4)
    405c:	1a 3c       	jmp	$+54     	;abs 0x4092
			state[i][j] = 4*i+j;
    405e:	1f 44 c6 ff 	mov	-58(r4),r15	;0xffc6(r4)
    4062:	4f 4f       	mov.b	r15,	r15	
    4064:	4f 4f       	mov.b	r15,	r15	
    4066:	4f 4f       	mov.b	r15,	r15	
    4068:	4f 5f       	rla.b	r15		
    406a:	4f 5f       	rla.b	r15		
    406c:	1e 44 c8 ff 	mov	-56(r4),r14	;0xffc8(r4)
    4070:	4e 4e       	mov.b	r14,	r14	
    4072:	4e 5f       	add.b	r15,	r14	
    4074:	1f 44 c6 ff 	mov	-58(r4),r15	;0xffc6(r4)
    4078:	0f 5f       	rla	r15		
    407a:	0f 5f       	rla	r15		
    407c:	3d 40 c6 ff 	mov	#-58,	r13	;#0xffc6
    4080:	0d 54       	add	r4,	r13	
    4082:	0f 5d       	add	r13,	r15	
    4084:	1f 54 c8 ff 	add	-56(r4),r15	;0xffc8(r4)
    4088:	2f 52       	add	#4,	r15	;r2 As==10
    408a:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	int i,j;

	START_ENCRYPT();

	for(i = 0; i < 4; i++)
		for(j = 0; j < 4; j++)
    408e:	94 53 c8 ff 	inc	-56(r4)	;0xffc8(r4)
    4092:	a4 92 c8 ff 	cmp	#4,	-56(r4)	;r2 As==10, 0xffc8(r4)
    4096:	e3 3b       	jl	$-56     	;abs 0x405e
	u8 keys[32];
	int i,j;

	START_ENCRYPT();

	for(i = 0; i < 4; i++)
    4098:	94 53 c6 ff 	inc	-58(r4)	;0xffc6(r4)
    409c:	a4 92 c6 ff 	cmp	#4,	-58(r4)	;r2 As==10, 0xffc6(r4)
    40a0:	db 3b       	jl	$-72     	;abs 0x4058
		for(j = 0; j < 4; j++)
			state[i][j] = 4*i+j;

	for(i=0; i < 32; i++) keys[i] = i;	
    40a2:	84 43 c6 ff 	mov	#0,	-58(r4)	;r3 As==00, 0xffc6(r4)
    40a6:	0c 3c       	jmp	$+26     	;abs 0x40c0
    40a8:	1f 44 c6 ff 	mov	-58(r4),r15	;0xffc6(r4)
    40ac:	4e 4f       	mov.b	r15,	r14	
    40ae:	0f 44       	mov	r4,	r15	
    40b0:	3f 50 da ff 	add	#-38,	r15	;#0xffda
    40b4:	1f 54 c6 ff 	add	-58(r4),r15	;0xffc6(r4)
    40b8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    40bc:	94 53 c6 ff 	inc	-58(r4)	;0xffc6(r4)
    40c0:	b4 90 20 00 	cmp	#32,	-58(r4)	;#0x0020, 0xffc6(r4)
    40c4:	c6 ff 
    40c6:	f0 3b       	jl	$-30     	;abs 0x40a8
	
	LEDRound(state, keys);
    40c8:	0e 44       	mov	r4,	r14	
    40ca:	3e 50 da ff 	add	#-38,	r14	;#0xffda
    40ce:	0f 44       	mov	r4,	r15	
    40d0:	3f 50 ca ff 	add	#-54,	r15	;#0xffca
    40d4:	b0 12 3e 45 	call	#0x453e	
		for(j = 0; j < 4; j++)printf("%x ",state[i][j]);
		printf("\n");
		}
#endif

	START_DECRYPT();
    40d8:	b0 12 fe 48 	call	#0x48fe	

	invLEDRound(state, keys);
    40dc:	0e 44       	mov	r4,	r14	
    40de:	3e 50 da ff 	add	#-38,	r14	;#0xffda
    40e2:	0f 44       	mov	r4,	r15	
    40e4:	3f 50 ca ff 	add	#-54,	r15	;#0xffca
    40e8:	b0 12 82 47 	call	#0x4782	
	for(i = 0; i < 4; i++){
		for(j = 0; j < 4; j++)printf("%x ",state[i][j]);
		printf("\n");
		}
#endif
	END_EXPE();
    40ec:	b0 12 08 49 	call	#0x4908	
	return 0;
    40f0:	0f 43       	clr	r15		
}
    40f2:	31 50 38 00 	add	#56,	r1	;#0x0038

000040f6 <__stop_progExec__>:
    40f6:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    40fa:	fd 3f       	jmp	$-4      	;abs 0x40f6

000040fc <__ctors_end>:
    40fc:	30 40 0c 4a 	br	#0x4a0c	

00004100 <FieldMult>:
};

static const u8 invSbox[16] = {5, 14, 15, 8, 12, 1, 2, 13,11,4,6,3,0,7,9,10};

 u8 FieldMult(u8 a, u8 b)
{
    4100:	04 12       	push	r4		
    4102:	04 41       	mov	r1,	r4	
    4104:	24 53       	incd	r4		
    4106:	31 82       	sub	#8,	r1	;r2 As==11
    4108:	c4 4f fc ff 	mov.b	r15,	-4(r4)	;0xfffc(r4)
    410c:	c4 4e fd ff 	mov.b	r14,	-3(r4)	;0xfffd(r4)
	const u8 ReductionPoly = 0x3;
    4110:	f4 40 03 00 	mov.b	#3,	-6(r4)	;#0x0003, 0xfffa(r4)
    4114:	fa ff 
	u8 x = a, ret = 0;
    4116:	d4 44 fc ff 	mov.b	-4(r4),	-10(r4)	;0xfffc(r4), 0xfff6(r4)
    411a:	f6 ff 
    411c:	c4 43 f7 ff 	mov.b	#0,	-9(r4)	;r3 As==00, 0xfff7(r4)
	int i;
	for(i = 0; i < 4; i++) {
    4120:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4124:	2b 3c       	jmp	$+88     	;abs 0x417c
		if((b>>i)&1) ret ^= x;
    4126:	5f 44 fd ff 	mov.b	-3(r4),	r15	;0xfffd(r4)
    412a:	1e 44 f8 ff 	mov	-8(r4),	r14	;0xfff8(r4)
    412e:	4e 4e       	mov.b	r14,	r14	
    4130:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    4134:	4e 93       	tst.b	r14		
    4136:	04 24       	jz	$+10     	;abs 0x4140
    4138:	0f 11       	rra	r15		
    413a:	7e 53       	add.b	#-1,	r14	;r3 As==11
    413c:	4e 93       	tst.b	r14		
    413e:	fc 23       	jnz	$-6      	;abs 0x4138
    4140:	1f f3       	and	#1,	r15	;r3 As==01
    4142:	4f 4f       	mov.b	r15,	r15	
    4144:	4f 93       	tst.b	r15		
    4146:	03 24       	jz	$+8      	;abs 0x414e
    4148:	d4 e4 f6 ff 	xor.b	-10(r4),-9(r4)	;0xfff6(r4), 0xfff7(r4)
    414c:	f7 ff 
		if(x&0x8) {
    414e:	5f 44 f6 ff 	mov.b	-10(r4),r15	;0xfff6(r4)
    4152:	3f f2       	and	#8,	r15	;r2 As==11
    4154:	0f 93       	tst	r15		
    4156:	0a 24       	jz	$+22     	;abs 0x416c
			x <<= 1;
    4158:	5f 44 f6 ff 	mov.b	-10(r4),r15	;0xfff6(r4)
    415c:	4f 4f       	mov.b	r15,	r15	
    415e:	4f 5f       	rla.b	r15		
    4160:	c4 4f f6 ff 	mov.b	r15,	-10(r4)	;0xfff6(r4)
			x ^= ReductionPoly;
    4164:	d4 e4 fa ff 	xor.b	-6(r4),	-10(r4)	;0xfffa(r4), 0xfff6(r4)
    4168:	f6 ff 
    416a:	06 3c       	jmp	$+14     	;abs 0x4178
		}
		else x <<= 1;
    416c:	5f 44 f6 ff 	mov.b	-10(r4),r15	;0xfff6(r4)
    4170:	4f 4f       	mov.b	r15,	r15	
    4172:	4f 5f       	rla.b	r15		
    4174:	c4 4f f6 ff 	mov.b	r15,	-10(r4)	;0xfff6(r4)
 u8 FieldMult(u8 a, u8 b)
{
	const u8 ReductionPoly = 0x3;
	u8 x = a, ret = 0;
	int i;
	for(i = 0; i < 4; i++) {
    4178:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    417c:	a4 92 f8 ff 	cmp	#4,	-8(r4)	;r2 As==10, 0xfff8(r4)
    4180:	d2 3b       	jl	$-90     	;abs 0x4126
			x <<= 1;
			x ^= ReductionPoly;
		}
		else x <<= 1;
	}
	return ret&WORDFILTER;
    4182:	5f 44 f7 ff 	mov.b	-9(r4),	r15	;0xfff7(r4)
    4186:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
}
    418a:	31 52       	add	#8,	r1	;r2 As==11
    418c:	34 41       	pop	r4		
    418e:	30 41       	ret			

00004190 <AddKey>:
 * else use the second half of the key
 * 
 * The key bytes are added row wise, i.e., first row , then second row etc.
 * */
 void AddKey(u8 state[4][4], u8* keyBytes, int half)
{
    4190:	04 12       	push	r4		
    4192:	04 41       	mov	r1,	r4	
    4194:	24 53       	incd	r4		
    4196:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    419a:	84 4f f8 ff 	mov	r15,	-8(r4)	;0xfff8(r4)
    419e:	84 4e fa ff 	mov	r14,	-6(r4)	;0xfffa(r4)
    41a2:	84 4d fc ff 	mov	r13,	-4(r4)	;0xfffc(r4)
	int i, j;
	if((half&1) == 0){
    41a6:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    41aa:	1f f3       	and	#1,	r15	;r3 As==01
    41ac:	0f 93       	tst	r15		
    41ae:	30 20       	jnz	$+98     	;abs 0x4210
		for(i = 0; i < 4; i++)
    41b0:	84 43 f4 ff 	mov	#0,	-12(r4)	;r3 As==00, 0xfff4(r4)
    41b4:	29 3c       	jmp	$+84     	;abs 0x4208
			for(j = 0; j < 4; j++)
    41b6:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    41ba:	21 3c       	jmp	$+68     	;abs 0x41fe
				state[i][j] ^= keyBytes[4*i+j];
    41bc:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    41c0:	0f 5f       	rla	r15		
    41c2:	0f 5f       	rla	r15		
    41c4:	1d 44 f8 ff 	mov	-8(r4),	r13	;0xfff8(r4)
    41c8:	0d 5f       	add	r15,	r13	
    41ca:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    41ce:	0f 5f       	rla	r15		
    41d0:	0f 5f       	rla	r15		
    41d2:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    41d6:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    41da:	6e 4f       	mov.b	@r15,	r14	
    41dc:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    41e0:	0f 5f       	rla	r15		
    41e2:	0f 5f       	rla	r15		
    41e4:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    41e8:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    41ec:	6f 4f       	mov.b	@r15,	r15	
    41ee:	4e ef       	xor.b	r15,	r14	
    41f0:	0f 4d       	mov	r13,	r15	
    41f2:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    41f6:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
 void AddKey(u8 state[4][4], u8* keyBytes, int half)
{
	int i, j;
	if((half&1) == 0){
		for(i = 0; i < 4; i++)
			for(j = 0; j < 4; j++)
    41fa:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    41fe:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    4202:	dc 3b       	jl	$-70     	;abs 0x41bc
 * */
 void AddKey(u8 state[4][4], u8* keyBytes, int half)
{
	int i, j;
	if((half&1) == 0){
		for(i = 0; i < 4; i++)
    4204:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    4208:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    420c:	d4 3b       	jl	$-86     	;abs 0x41b6
    420e:	2f 3c       	jmp	$+96     	;abs 0x426e
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j];
	}
	else{
		for(i = 0; i < 4; i++)
    4210:	84 43 f4 ff 	mov	#0,	-12(r4)	;r3 As==00, 0xfff4(r4)
    4214:	29 3c       	jmp	$+84     	;abs 0x4268
			for(j = 0; j < 4; j++)
    4216:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    421a:	21 3c       	jmp	$+68     	;abs 0x425e
				state[i][j] ^= keyBytes[4*i+j+((LED-64)>>2)];
    421c:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    4220:	0f 5f       	rla	r15		
    4222:	0f 5f       	rla	r15		
    4224:	1d 44 f8 ff 	mov	-8(r4),	r13	;0xfff8(r4)
    4228:	0d 5f       	add	r15,	r13	
    422a:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    422e:	0f 5f       	rla	r15		
    4230:	0f 5f       	rla	r15		
    4232:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    4236:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    423a:	6e 4f       	mov.b	@r15,	r14	
    423c:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    4240:	0f 5f       	rla	r15		
    4242:	0f 5f       	rla	r15		
    4244:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4248:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    424c:	6f 4f       	mov.b	@r15,	r15	
    424e:	4e ef       	xor.b	r15,	r14	
    4250:	0f 4d       	mov	r13,	r15	
    4252:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4256:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j];
	}
	else{
		for(i = 0; i < 4; i++)
			for(j = 0; j < 4; j++)
    425a:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    425e:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    4262:	dc 3b       	jl	$-70     	;abs 0x421c
		for(i = 0; i < 4; i++)
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j];
	}
	else{
		for(i = 0; i < 4; i++)
    4264:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    4268:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    426c:	d4 3b       	jl	$-86     	;abs 0x4216
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j+((LED-64)>>2)];
	}
}
    426e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    4272:	34 41       	pop	r4		
    4274:	30 41       	ret			

00004276 <AddConstants>:

 void AddConstants(u8 state[4][4], int r)
{
    4276:	04 12       	push	r4		
    4278:	04 41       	mov	r1,	r4	
    427a:	24 53       	incd	r4		
    427c:	31 50 ca ff 	add	#-54,	r1	;#0xffca
    4280:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    4284:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	const u8 RC[48] = {
    4288:	0f 44       	mov	r4,	r15	
    428a:	3f 50 c9 ff 	add	#-55,	r15	;#0xffc9
    428e:	3e 40 00 11 	mov	#4352,	r14	;#0x1100
    4292:	3d 40 30 00 	mov	#48,	r13	;#0x0030
    4296:	b0 12 12 49 	call	#0x4912	
		0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B,
		0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05, 0x0B, 0x17, 0x2E,
		0x1C, 0x38, 0x31, 0x23, 0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A,
		0x34, 0x29, 0x12, 0x24, 0x08, 0x11, 0x22, 0x04
	};
	state[1][0] ^= 1;
    429a:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    429e:	2f 52       	add	#4,	r15	;r2 As==10
    42a0:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    42a4:	2e 52       	add	#4,	r14	;r2 As==10
    42a6:	6e 4e       	mov.b	@r14,	r14	
    42a8:	5e e3       	xor.b	#1,	r14	;r3 As==01
    42aa:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	state[2][0] ^= 2;
    42ae:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    42b2:	3f 52       	add	#8,	r15	;r2 As==11
    42b4:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    42b8:	3e 52       	add	#8,	r14	;r2 As==11
    42ba:	6e 4e       	mov.b	@r14,	r14	
    42bc:	6e e3       	xor.b	#2,	r14	;r3 As==10
    42be:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	state[3][0] ^= 3;
    42c2:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    42c6:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    42ca:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    42ce:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    42d2:	6e 4e       	mov.b	@r14,	r14	
    42d4:	7e e0 03 00 	xor.b	#3,	r14	;#0x0003
    42d8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)

	u8 tmp = (RC[r] >> 3) & 7;
    42dc:	0f 44       	mov	r4,	r15	
    42de:	3f 50 c9 ff 	add	#-55,	r15	;#0xffc9
    42e2:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    42e6:	6f 4f       	mov.b	@r15,	r15	
    42e8:	4f 4f       	mov.b	r15,	r15	
    42ea:	4f 4f       	mov.b	r15,	r15	
    42ec:	12 c3       	clrc			
    42ee:	4f 10       	rrc.b	r15		
    42f0:	12 c3       	clrc			
    42f2:	4f 10       	rrc.b	r15		
    42f4:	12 c3       	clrc			
    42f6:	4f 10       	rrc.b	r15		
    42f8:	4e 4f       	mov.b	r15,	r14	
    42fa:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    42fe:	c4 4e c8 ff 	mov.b	r14,	-56(r4)	;0xffc8(r4)
	state[0][1] ^= tmp;
    4302:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4306:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    430a:	4e 4f       	mov.b	r15,	r14	
    430c:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    4310:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4314:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
	state[2][1] ^= tmp;
    4318:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    431c:	3f 52       	add	#8,	r15	;r2 As==11
    431e:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    4322:	3e 52       	add	#8,	r14	;r2 As==11
    4324:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    4328:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    432c:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
	tmp =  RC[r] & 7;
    4330:	0f 44       	mov	r4,	r15	
    4332:	3f 50 c9 ff 	add	#-55,	r15	;#0xffc9
    4336:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    433a:	6f 4f       	mov.b	@r15,	r15	
    433c:	4e 4f       	mov.b	r15,	r14	
    433e:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    4342:	c4 4e c8 ff 	mov.b	r14,	-56(r4)	;0xffc8(r4)
	state[1][1] ^= tmp;
    4346:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    434a:	2f 52       	add	#4,	r15	;r2 As==10
    434c:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    4350:	2e 52       	add	#4,	r14	;r2 As==10
    4352:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    4356:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    435a:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
	state[3][1] ^= tmp;
    435e:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4362:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    4366:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    436a:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    436e:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    4372:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    4376:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
}
    437a:	31 50 36 00 	add	#54,	r1	;#0x0036
    437e:	34 41       	pop	r4		
    4380:	30 41       	ret			

00004382 <SubCell>:

 void SubCell(u8 state[4][4])
{
    4382:	04 12       	push	r4		
    4384:	04 41       	mov	r1,	r4	
    4386:	24 53       	incd	r4		
    4388:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    438c:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int i,j;
	for(i = 0; i < 4; i++)
    4390:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4394:	22 3c       	jmp	$+70     	;abs 0x43da
		for(j = 0; j <  4; j++)
    4396:	84 43 fa ff 	mov	#0,	-6(r4)	;r3 As==00, 0xfffa(r4)
    439a:	1a 3c       	jmp	$+54     	;abs 0x43d0
			state[i][j] = sbox[state[i][j]];
    439c:	1f 44 f8 ff 	mov	-8(r4),	r15	;0xfff8(r4)
    43a0:	0f 5f       	rla	r15		
    43a2:	0f 5f       	rla	r15		
    43a4:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    43a8:	0d 5f       	add	r15,	r13	
    43aa:	1f 44 f8 ff 	mov	-8(r4),	r15	;0xfff8(r4)
    43ae:	0f 5f       	rla	r15		
    43b0:	0f 5f       	rla	r15		
    43b2:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    43b6:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    43ba:	6f 4f       	mov.b	@r15,	r15	
    43bc:	4f 4f       	mov.b	r15,	r15	
    43be:	5e 4f 1e 4a 	mov.b	18974(r15),r14	;0x4a1e(r15)
    43c2:	0f 4d       	mov	r13,	r15	
    43c4:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    43c8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)

 void SubCell(u8 state[4][4])
{
	int i,j;
	for(i = 0; i < 4; i++)
		for(j = 0; j <  4; j++)
    43cc:	94 53 fa ff 	inc	-6(r4)		;0xfffa(r4)
    43d0:	a4 92 fa ff 	cmp	#4,	-6(r4)	;r2 As==10, 0xfffa(r4)
    43d4:	e3 3b       	jl	$-56     	;abs 0x439c
}

 void SubCell(u8 state[4][4])
{
	int i,j;
	for(i = 0; i < 4; i++)
    43d6:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    43da:	a4 92 f8 ff 	cmp	#4,	-8(r4)	;r2 As==10, 0xfff8(r4)
    43de:	db 3b       	jl	$-72     	;abs 0x4396
		for(j = 0; j <  4; j++)
			state[i][j] = sbox[state[i][j]];
}
    43e0:	31 50 06 00 	add	#6,	r1	;#0x0006
    43e4:	34 41       	pop	r4		
    43e6:	30 41       	ret			

000043e8 <ShiftRow>:

 void ShiftRow(u8 state[4][4])
{
    43e8:	04 12       	push	r4		
    43ea:	04 41       	mov	r1,	r4	
    43ec:	24 53       	incd	r4		
    43ee:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    43f2:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) {
    43f6:	94 43 f4 ff 	mov	#1,	-12(r4)	;r3 As==01, 0xfff4(r4)
    43fa:	3d 3c       	jmp	$+124    	;abs 0x4476
		for(j = 0; j < 4; j++)
    43fc:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4400:	11 3c       	jmp	$+36     	;abs 0x4424
			tmp[j] = state[i][j];
    4402:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    4406:	0f 5f       	rla	r15		
    4408:	0f 5f       	rla	r15		
    440a:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    440e:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4412:	6e 4f       	mov.b	@r15,	r14	
    4414:	0f 44       	mov	r4,	r15	
    4416:	3f 82       	sub	#8,	r15	;r2 As==11
    4418:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    441c:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
 void ShiftRow(u8 state[4][4])
{
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) {
		for(j = 0; j < 4; j++)
    4420:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    4424:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    4428:	ec 3b       	jl	$-38     	;abs 0x4402
			tmp[j] = state[i][j];
		for(j = 0; j < 4; j++)
    442a:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    442e:	1e 3c       	jmp	$+62     	;abs 0x446c
			state[i][j] = tmp[(j+i)%4];
    4430:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    4434:	0f 5f       	rla	r15		
    4436:	0f 5f       	rla	r15		
    4438:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    443c:	0d 5f       	add	r15,	r13	
    443e:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    4442:	1f 54 f4 ff 	add	-12(r4),r15	;0xfff4(r4)
    4446:	3f f0 03 80 	and	#-32765,r15	;#0x8003
    444a:	0f 93       	tst	r15		
    444c:	04 34       	jge	$+10     	;abs 0x4456
    444e:	3f 53       	add	#-1,	r15	;r3 As==11
    4450:	3f d0 fc ff 	bis	#-4,	r15	;#0xfffc
    4454:	1f 53       	inc	r15		
    4456:	0e 44       	mov	r4,	r14	
    4458:	3e 82       	sub	#8,	r14	;r2 As==11
    445a:	0f 5e       	add	r14,	r15	
    445c:	6e 4f       	mov.b	@r15,	r14	
    445e:	0f 4d       	mov	r13,	r15	
    4460:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4464:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) {
		for(j = 0; j < 4; j++)
			tmp[j] = state[i][j];
		for(j = 0; j < 4; j++)
    4468:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    446c:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    4470:	df 3b       	jl	$-64     	;abs 0x4430

 void ShiftRow(u8 state[4][4])
{
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) {
    4472:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    4476:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    447a:	c0 3b       	jl	$-126    	;abs 0x43fc
		for(j = 0; j < 4; j++)
			tmp[j] = state[i][j];
		for(j = 0; j < 4; j++)
			state[i][j] = tmp[(j+i)%4];
	}
}
    447c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    4480:	34 41       	pop	r4		
    4482:	30 41       	ret			

00004484 <MixColumn>:

 void MixColumn(u8 state[4][4])
{
    4484:	04 12       	push	r4		
    4486:	04 41       	mov	r1,	r4	
    4488:	24 53       	incd	r4		
    448a:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    448e:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
    4492:	84 43 f2 ff 	mov	#0,	-14(r4)	;r3 As==00, 0xfff2(r4)
    4496:	4c 3c       	jmp	$+154    	;abs 0x4530
		for(i = 0; i < 4; i++) {
    4498:	84 43 f0 ff 	mov	#0,	-16(r4)	;r3 As==00, 0xfff0(r4)
    449c:	2a 3c       	jmp	$+86     	;abs 0x44f2
			u8 sum = 0;
    449e:	c4 43 f6 ff 	mov.b	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
			for(k = 0; k < 4; k++)
    44a2:	84 43 f4 ff 	mov	#0,	-12(r4)	;r3 As==00, 0xfff4(r4)
    44a6:	18 3c       	jmp	$+50     	;abs 0x44d8
				sum ^= FieldMult(MixColMatrix[i][k], state[k][j]);
    44a8:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    44ac:	0f 5f       	rla	r15		
    44ae:	0f 5f       	rla	r15		
    44b0:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    44b4:	1f 54 f2 ff 	add	-14(r4),r15	;0xfff2(r4)
    44b8:	6e 4f       	mov.b	@r15,	r14	
    44ba:	1f 44 f0 ff 	mov	-16(r4),r15	;0xfff0(r4)
    44be:	0f 5f       	rla	r15		
    44c0:	0f 5f       	rla	r15		
    44c2:	1f 54 f4 ff 	add	-12(r4),r15	;0xfff4(r4)
    44c6:	3f 50 0e 4a 	add	#18958,	r15	;#0x4a0e
    44ca:	6f 4f       	mov.b	@r15,	r15	
    44cc:	b0 12 00 41 	call	#0x4100	
    44d0:	c4 ef f6 ff 	xor.b	r15,	-10(r4)	;0xfff6(r4)
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
		for(i = 0; i < 4; i++) {
			u8 sum = 0;
			for(k = 0; k < 4; k++)
    44d4:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    44d8:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    44dc:	e5 3b       	jl	$-52     	;abs 0x44a8
				sum ^= FieldMult(MixColMatrix[i][k], state[k][j]);
			tmp[i] = sum;
    44de:	0f 44       	mov	r4,	r15	
    44e0:	3f 50 f7 ff 	add	#-9,	r15	;#0xfff7
    44e4:	1f 54 f0 ff 	add	-16(r4),r15	;0xfff0(r4)
    44e8:	df 44 f6 ff 	mov.b	-10(r4),0(r15)	;0xfff6(r4), 0x0000(r15)
    44ec:	00 00 
 void MixColumn(u8 state[4][4])
{
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
		for(i = 0; i < 4; i++) {
    44ee:	94 53 f0 ff 	inc	-16(r4)	;0xfff0(r4)
    44f2:	a4 92 f0 ff 	cmp	#4,	-16(r4)	;r2 As==10, 0xfff0(r4)
    44f6:	d3 3b       	jl	$-88     	;abs 0x449e
			u8 sum = 0;
			for(k = 0; k < 4; k++)
				sum ^= FieldMult(MixColMatrix[i][k], state[k][j]);
			tmp[i] = sum;
		}
		for(i = 0; i < 4; i++)
    44f8:	84 43 f0 ff 	mov	#0,	-16(r4)	;r3 As==00, 0xfff0(r4)
    44fc:	14 3c       	jmp	$+42     	;abs 0x4526
			state[i][j] = tmp[i];
    44fe:	1f 44 f0 ff 	mov	-16(r4),r15	;0xfff0(r4)
    4502:	0f 5f       	rla	r15		
    4504:	0f 5f       	rla	r15		
    4506:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    450a:	0d 5f       	add	r15,	r13	
    450c:	0f 44       	mov	r4,	r15	
    450e:	3f 50 f7 ff 	add	#-9,	r15	;#0xfff7
    4512:	1f 54 f0 ff 	add	-16(r4),r15	;0xfff0(r4)
    4516:	6e 4f       	mov.b	@r15,	r14	
    4518:	0f 4d       	mov	r13,	r15	
    451a:	1f 54 f2 ff 	add	-14(r4),r15	;0xfff2(r4)
    451e:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
			u8 sum = 0;
			for(k = 0; k < 4; k++)
				sum ^= FieldMult(MixColMatrix[i][k], state[k][j]);
			tmp[i] = sum;
		}
		for(i = 0; i < 4; i++)
    4522:	94 53 f0 ff 	inc	-16(r4)	;0xfff0(r4)
    4526:	a4 92 f0 ff 	cmp	#4,	-16(r4)	;r2 As==10, 0xfff0(r4)
    452a:	e9 3b       	jl	$-44     	;abs 0x44fe

 void MixColumn(u8 state[4][4])
{
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
    452c:	94 53 f2 ff 	inc	-14(r4)	;0xfff2(r4)
    4530:	a4 92 f2 ff 	cmp	#4,	-14(r4)	;r2 As==10, 0xfff2(r4)
    4534:	b1 3b       	jl	$-156    	;abs 0x4498
			tmp[i] = sum;
		}
		for(i = 0; i < 4; i++)
			state[i][j] = tmp[i];
	}
}
    4536:	31 50 0e 00 	add	#14,	r1	;#0x000e
    453a:	34 41       	pop	r4		
    453c:	30 41       	ret			

0000453e <LEDRound>:

 void LEDRound(u8 state[4][4], u8* keyBytes)
{
    453e:	04 12       	push	r4		
    4540:	04 41       	mov	r1,	r4	
    4542:	24 53       	incd	r4		
    4544:	31 82       	sub	#8,	r1	;r2 As==11
    4546:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    454a:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	int i,j;
	AddKey(state, keyBytes, 0);
    454e:	0d 43       	clr	r13		
    4550:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    4554:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4558:	b0 12 90 41 	call	#0x4190	
	for(i = 0; i < RN/4; i++){
    455c:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4560:	2b 3c       	jmp	$+88     	;abs 0x45b8
		for(j = 0; j < 4; j++)
    4562:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4566:	19 3c       	jmp	$+52     	;abs 0x459a
		{
			AddConstants(state, i*4+j);
    4568:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    456c:	0f 5f       	rla	r15		
    456e:	0f 5f       	rla	r15		
    4570:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    4574:	0e 4f       	mov	r15,	r14	
    4576:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    457a:	b0 12 76 42 	call	#0x4276	
			SubCell(state);
    457e:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4582:	b0 12 82 43 	call	#0x4382	
			ShiftRow(state);
    4586:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    458a:	b0 12 e8 43 	call	#0x43e8	
			MixColumn(state);
    458e:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4592:	b0 12 84 44 	call	#0x4484	
 void LEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	AddKey(state, keyBytes, 0);
	for(i = 0; i < RN/4; i++){
		for(j = 0; j < 4; j++)
    4596:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    459a:	a4 92 f8 ff 	cmp	#4,	-8(r4)	;r2 As==10, 0xfff8(r4)
    459e:	e4 3b       	jl	$-54     	;abs 0x4568
			AddConstants(state, i*4+j);
			SubCell(state);
			ShiftRow(state);
			MixColumn(state);
		}
		AddKey(state, keyBytes, i+1);
    45a0:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    45a4:	1f 53       	inc	r15		
    45a6:	0d 4f       	mov	r15,	r13	
    45a8:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    45ac:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    45b0:	b0 12 90 41 	call	#0x4190	

 void LEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	AddKey(state, keyBytes, 0);
	for(i = 0; i < RN/4; i++){
    45b4:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    45b8:	b4 92 f6 ff 	cmp	#8,	-10(r4)	;r2 As==11, 0xfff6(r4)
    45bc:	d2 3b       	jl	$-90     	;abs 0x4562
			ShiftRow(state);
			MixColumn(state);
		}
		AddKey(state, keyBytes, i+1);
	}
}
    45be:	31 52       	add	#8,	r1	;r2 As==11
    45c0:	34 41       	pop	r4		
    45c2:	30 41       	ret			

000045c4 <invSubCell>:


/************************************************************************/
 void invSubCell(u8 state[4][4])
{
    45c4:	04 12       	push	r4		
    45c6:	04 41       	mov	r1,	r4	
    45c8:	24 53       	incd	r4		
    45ca:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    45ce:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int i,j;
	for(i = 0; i < 4; i++)
    45d2:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    45d6:	22 3c       	jmp	$+70     	;abs 0x461c
		for(j = 0; j <  4; j++)
    45d8:	84 43 fa ff 	mov	#0,	-6(r4)	;r3 As==00, 0xfffa(r4)
    45dc:	1a 3c       	jmp	$+54     	;abs 0x4612
			state[i][j] = invSbox[state[i][j]];
    45de:	1f 44 f8 ff 	mov	-8(r4),	r15	;0xfff8(r4)
    45e2:	0f 5f       	rla	r15		
    45e4:	0f 5f       	rla	r15		
    45e6:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    45ea:	0d 5f       	add	r15,	r13	
    45ec:	1f 44 f8 ff 	mov	-8(r4),	r15	;0xfff8(r4)
    45f0:	0f 5f       	rla	r15		
    45f2:	0f 5f       	rla	r15		
    45f4:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    45f8:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    45fc:	6f 4f       	mov.b	@r15,	r15	
    45fe:	4f 4f       	mov.b	r15,	r15	
    4600:	5e 4f 3e 4a 	mov.b	19006(r15),r14	;0x4a3e(r15)
    4604:	0f 4d       	mov	r13,	r15	
    4606:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    460a:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
/************************************************************************/
 void invSubCell(u8 state[4][4])
{
	int i,j;
	for(i = 0; i < 4; i++)
		for(j = 0; j <  4; j++)
    460e:	94 53 fa ff 	inc	-6(r4)		;0xfffa(r4)
    4612:	a4 92 fa ff 	cmp	#4,	-6(r4)	;r2 As==10, 0xfffa(r4)
    4616:	e3 3b       	jl	$-56     	;abs 0x45de

/************************************************************************/
 void invSubCell(u8 state[4][4])
{
	int i,j;
	for(i = 0; i < 4; i++)
    4618:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    461c:	a4 92 f8 ff 	cmp	#4,	-8(r4)	;r2 As==10, 0xfff8(r4)
    4620:	db 3b       	jl	$-72     	;abs 0x45d8
		for(j = 0; j <  4; j++)
			state[i][j] = invSbox[state[i][j]];
}
    4622:	31 50 06 00 	add	#6,	r1	;#0x0006
    4626:	34 41       	pop	r4		
    4628:	30 41       	ret			

0000462a <invShiftRow>:

 void invShiftRow(u8 state[4][4])
{
    462a:	04 12       	push	r4		
    462c:	04 41       	mov	r1,	r4	
    462e:	24 53       	incd	r4		
    4630:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    4634:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) 
    4638:	94 43 f4 ff 	mov	#1,	-12(r4)	;r3 As==01, 0xfff4(r4)
    463c:	3e 3c       	jmp	$+126    	;abs 0x46ba
	{
		for(j = 0; j < 4; j++)
    463e:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4642:	11 3c       	jmp	$+36     	;abs 0x4666
			tmp[j] = state[i][j];
    4644:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    4648:	0f 5f       	rla	r15		
    464a:	0f 5f       	rla	r15		
    464c:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    4650:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4654:	6e 4f       	mov.b	@r15,	r14	
    4656:	0f 44       	mov	r4,	r15	
    4658:	3f 82       	sub	#8,	r15	;r2 As==11
    465a:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    465e:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
{
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) 
	{
		for(j = 0; j < 4; j++)
    4662:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    4666:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    466a:	ec 3b       	jl	$-38     	;abs 0x4644
			tmp[j] = state[i][j];
		for(j = 0; j < 4; j++)
    466c:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4670:	1f 3c       	jmp	$+64     	;abs 0x46b0
			state[i][j] = tmp[(j+(4-i))%4];
    4672:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    4676:	0f 5f       	rla	r15		
    4678:	0f 5f       	rla	r15		
    467a:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    467e:	0d 5f       	add	r15,	r13	
    4680:	2f 42       	mov	#4,	r15	;r2 As==10
    4682:	1f 84 f4 ff 	sub	-12(r4),r15	;0xfff4(r4)
    4686:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    468a:	3f f0 03 80 	and	#-32765,r15	;#0x8003
    468e:	0f 93       	tst	r15		
    4690:	04 34       	jge	$+10     	;abs 0x469a
    4692:	3f 53       	add	#-1,	r15	;r3 As==11
    4694:	3f d0 fc ff 	bis	#-4,	r15	;#0xfffc
    4698:	1f 53       	inc	r15		
    469a:	0e 44       	mov	r4,	r14	
    469c:	3e 82       	sub	#8,	r14	;r2 As==11
    469e:	0f 5e       	add	r14,	r15	
    46a0:	6e 4f       	mov.b	@r15,	r14	
    46a2:	0f 4d       	mov	r13,	r15	
    46a4:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    46a8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	u8 tmp[4];
	for(i = 1; i < 4; i++) 
	{
		for(j = 0; j < 4; j++)
			tmp[j] = state[i][j];
		for(j = 0; j < 4; j++)
    46ac:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    46b0:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    46b4:	de 3b       	jl	$-66     	;abs 0x4672

 void invShiftRow(u8 state[4][4])
{
	int i, j;
	u8 tmp[4];
	for(i = 1; i < 4; i++) 
    46b6:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    46ba:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    46be:	bf 3b       	jl	$-128    	;abs 0x463e
		for(j = 0; j < 4; j++)
			tmp[j] = state[i][j];
		for(j = 0; j < 4; j++)
			state[i][j] = tmp[(j+(4-i))%4];
	}
}
    46c0:	31 50 0a 00 	add	#10,	r1	;#0x000a
    46c4:	34 41       	pop	r4		
    46c6:	30 41       	ret			

000046c8 <invMixColumn>:


 void invMixColumn(u8 state[4][4])
{
    46c8:	04 12       	push	r4		
    46ca:	04 41       	mov	r1,	r4	
    46cc:	24 53       	incd	r4		
    46ce:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    46d2:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
    46d6:	84 43 f2 ff 	mov	#0,	-14(r4)	;r3 As==00, 0xfff2(r4)
    46da:	4c 3c       	jmp	$+154    	;abs 0x4774
		for(i = 0; i < 4; i++) {
    46dc:	84 43 f0 ff 	mov	#0,	-16(r4)	;r3 As==00, 0xfff0(r4)
    46e0:	2a 3c       	jmp	$+86     	;abs 0x4736
			u8 sum = 0;
    46e2:	c4 43 f6 ff 	mov.b	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
			for(k = 0; k < 4; k++)
    46e6:	84 43 f4 ff 	mov	#0,	-12(r4)	;r3 As==00, 0xfff4(r4)
    46ea:	18 3c       	jmp	$+50     	;abs 0x471c
				sum ^= FieldMult(invMixColMatrix[i][k], state[k][j]);
    46ec:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    46f0:	0f 5f       	rla	r15		
    46f2:	0f 5f       	rla	r15		
    46f4:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    46f8:	1f 54 f2 ff 	add	-14(r4),r15	;0xfff2(r4)
    46fc:	6e 4f       	mov.b	@r15,	r14	
    46fe:	1f 44 f0 ff 	mov	-16(r4),r15	;0xfff0(r4)
    4702:	0f 5f       	rla	r15		
    4704:	0f 5f       	rla	r15		
    4706:	1f 54 f4 ff 	add	-12(r4),r15	;0xfff4(r4)
    470a:	3f 50 2e 4a 	add	#18990,	r15	;#0x4a2e
    470e:	6f 4f       	mov.b	@r15,	r15	
    4710:	b0 12 00 41 	call	#0x4100	
    4714:	c4 ef f6 ff 	xor.b	r15,	-10(r4)	;0xfff6(r4)
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
		for(i = 0; i < 4; i++) {
			u8 sum = 0;
			for(k = 0; k < 4; k++)
    4718:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    471c:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    4720:	e5 3b       	jl	$-52     	;abs 0x46ec
				sum ^= FieldMult(invMixColMatrix[i][k], state[k][j]);
			tmp[i] = sum;
    4722:	0f 44       	mov	r4,	r15	
    4724:	3f 50 f7 ff 	add	#-9,	r15	;#0xfff7
    4728:	1f 54 f0 ff 	add	-16(r4),r15	;0xfff0(r4)
    472c:	df 44 f6 ff 	mov.b	-10(r4),0(r15)	;0xfff6(r4), 0x0000(r15)
    4730:	00 00 
 void invMixColumn(u8 state[4][4])
{
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
		for(i = 0; i < 4; i++) {
    4732:	94 53 f0 ff 	inc	-16(r4)	;0xfff0(r4)
    4736:	a4 92 f0 ff 	cmp	#4,	-16(r4)	;r2 As==10, 0xfff0(r4)
    473a:	d3 3b       	jl	$-88     	;abs 0x46e2
			u8 sum = 0;
			for(k = 0; k < 4; k++)
				sum ^= FieldMult(invMixColMatrix[i][k], state[k][j]);
			tmp[i] = sum;
		}
		for(i = 0; i < 4; i++)
    473c:	84 43 f0 ff 	mov	#0,	-16(r4)	;r3 As==00, 0xfff0(r4)
    4740:	14 3c       	jmp	$+42     	;abs 0x476a
			state[i][j] = tmp[i];
    4742:	1f 44 f0 ff 	mov	-16(r4),r15	;0xfff0(r4)
    4746:	0f 5f       	rla	r15		
    4748:	0f 5f       	rla	r15		
    474a:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    474e:	0d 5f       	add	r15,	r13	
    4750:	0f 44       	mov	r4,	r15	
    4752:	3f 50 f7 ff 	add	#-9,	r15	;#0xfff7
    4756:	1f 54 f0 ff 	add	-16(r4),r15	;0xfff0(r4)
    475a:	6e 4f       	mov.b	@r15,	r14	
    475c:	0f 4d       	mov	r13,	r15	
    475e:	1f 54 f2 ff 	add	-14(r4),r15	;0xfff2(r4)
    4762:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
			u8 sum = 0;
			for(k = 0; k < 4; k++)
				sum ^= FieldMult(invMixColMatrix[i][k], state[k][j]);
			tmp[i] = sum;
		}
		for(i = 0; i < 4; i++)
    4766:	94 53 f0 ff 	inc	-16(r4)	;0xfff0(r4)
    476a:	a4 92 f0 ff 	cmp	#4,	-16(r4)	;r2 As==10, 0xfff0(r4)
    476e:	e9 3b       	jl	$-44     	;abs 0x4742

 void invMixColumn(u8 state[4][4])
{
	int i, j, k;
	u8 tmp[4];
	for(j = 0; j < 4; j++){
    4770:	94 53 f2 ff 	inc	-14(r4)	;0xfff2(r4)
    4774:	a4 92 f2 ff 	cmp	#4,	-14(r4)	;r2 As==10, 0xfff2(r4)
    4778:	b1 3b       	jl	$-156    	;abs 0x46dc
			tmp[i] = sum;
		}
		for(i = 0; i < 4; i++)
			state[i][j] = tmp[i];
	}
}
    477a:	31 50 0e 00 	add	#14,	r1	;#0x000e
    477e:	34 41       	pop	r4		
    4780:	30 41       	ret			

00004782 <invLEDRound>:


 void invLEDRound(u8 state[4][4], u8* keyBytes)
{
    4782:	04 12       	push	r4		
    4784:	04 41       	mov	r1,	r4	
    4786:	24 53       	incd	r4		
    4788:	31 82       	sub	#8,	r1	;r2 As==11
    478a:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    478e:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	int i,j;
	for(i = (RN/4)-1; i >=0; i--){
    4792:	b4 40 07 00 	mov	#7,	-10(r4)	;#0x0007, 0xfff6(r4)
    4796:	f6 ff 
    4798:	2c 3c       	jmp	$+90     	;abs 0x47f2
		AddKey(state, keyBytes, i+1);
    479a:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    479e:	1f 53       	inc	r15		
    47a0:	0d 4f       	mov	r15,	r13	
    47a2:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    47a6:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    47aa:	b0 12 90 41 	call	#0x4190	
		for(j = 3; j >= 0; j--)
    47ae:	b4 40 03 00 	mov	#3,	-8(r4)	;#0x0003, 0xfff8(r4)
    47b2:	f8 ff 
    47b4:	19 3c       	jmp	$+52     	;abs 0x47e8
		{
			invMixColumn(state);
    47b6:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    47ba:	b0 12 c8 46 	call	#0x46c8	
			invShiftRow(state);
    47be:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    47c2:	b0 12 2a 46 	call	#0x462a	
			invSubCell(state);
    47c6:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    47ca:	b0 12 c4 45 	call	#0x45c4	
			AddConstants(state, i*4+j);
    47ce:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    47d2:	0f 5f       	rla	r15		
    47d4:	0f 5f       	rla	r15		
    47d6:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    47da:	0e 4f       	mov	r15,	r14	
    47dc:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    47e0:	b0 12 76 42 	call	#0x4276	
 void invLEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	for(i = (RN/4)-1; i >=0; i--){
		AddKey(state, keyBytes, i+1);
		for(j = 3; j >= 0; j--)
    47e4:	b4 53 f8 ff 	add	#-1,	-8(r4)	;r3 As==11, 0xfff8(r4)
    47e8:	84 93 f8 ff 	tst	-8(r4)		;0xfff8(r4)
    47ec:	e4 37       	jge	$-54     	;abs 0x47b6


 void invLEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	for(i = (RN/4)-1; i >=0; i--){
    47ee:	b4 53 f6 ff 	add	#-1,	-10(r4)	;r3 As==11, 0xfff6(r4)
    47f2:	84 93 f6 ff 	tst	-10(r4)	;0xfff6(r4)
    47f6:	d1 37       	jge	$-92     	;abs 0x479a
			invSubCell(state);
			AddConstants(state, i*4+j);
		}
		
	}
	AddKey(state, keyBytes, 0);
    47f8:	0d 43       	clr	r13		
    47fa:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    47fe:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4802:	b0 12 90 41 	call	#0x4190	
}
    4806:	31 52       	add	#8,	r1	;r2 As==11
    4808:	34 41       	pop	r4		
    480a:	30 41       	ret			

0000480c <delay>:
/**************************************************/
/********************* DELAY **********************/
/**************************************************/

void delay(unsigned int d) 
{
    480c:	04 12       	push	r4		
    480e:	04 41       	mov	r1,	r4	
    4810:	24 53       	incd	r4		
    4812:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    4816:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
  unsigned int i,j;
  for(j=0; j < 0xff; j++)
    481a:	84 43 fa ff 	mov	#0,	-6(r4)	;r3 As==00, 0xfffa(r4)
    481e:	0d 3c       	jmp	$+28     	;abs 0x483a
    {
      for (i = 0; i<d; i++) 
    4820:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4824:	04 3c       	jmp	$+10     	;abs 0x482e
	{
	  nop();
    4826:	03 43       	nop			
	  nop();
    4828:	03 43       	nop			
void delay(unsigned int d) 
{
  unsigned int i,j;
  for(j=0; j < 0xff; j++)
    {
      for (i = 0; i<d; i++) 
    482a:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    482e:	94 94 fc ff 	cmp	-4(r4),	-8(r4)	;0xfffc(r4), 0xfff8(r4)
    4832:	f8 ff 
    4834:	f8 2b       	jnc	$-14     	;abs 0x4826
/**************************************************/

void delay(unsigned int d) 
{
  unsigned int i,j;
  for(j=0; j < 0xff; j++)
    4836:	94 53 fa ff 	inc	-6(r4)		;0xfffa(r4)
    483a:	b4 90 ff 00 	cmp	#255,	-6(r4)	;#0x00ff, 0xfffa(r4)
    483e:	fa ff 
    4840:	ef 2b       	jnc	$-32     	;abs 0x4820
	{
	  nop();
	  nop();
	}
    }
}
    4842:	31 50 06 00 	add	#6,	r1	;#0x0006
    4846:	34 41       	pop	r4		
    4848:	30 41       	ret			

0000484a <uart1_init>:

#define UART1_BIT_RX (1 << UART1_PIN_RX)
#define UART1_BIT_TX (1 << UART1_PIN_TX)

int uart1_init()
{
    484a:	04 12       	push	r4		
    484c:	04 41       	mov	r1,	r4	
    484e:	24 53       	incd	r4		

  WDTCTL = WDTPW + WDTHOLD;
    4850:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    4854:	20 01 

  P1IE   = 0x00;        // Interrupt enable
    4856:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00
  P2IE   = 0x00;        // 0:disable 1:enable
    485a:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00

  //Init of MSP430 Usart1 pins
  P3SEL |= (UART1_BIT_RX | UART1_BIT_TX);
    485e:	5f 42 1b 00 	mov.b	&0x001b,r15	
    4862:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    4866:	c2 4f 1b 00 	mov.b	r15,	&0x001b	

  //Init of USART1 Module
  U1ME  |= UTXE1|URXE1;           //Enable USART1 transmiter and receiver (UART mode)
    486a:	5f 42 05 00 	mov.b	&0x0005,r15	
    486e:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4872:	c2 4f 05 00 	mov.b	r15,	&0x0005	
  
  U1CTL  = SWRST;                 //reset
    4876:	d2 43 78 00 	mov.b	#1,	&0x0078	;r3 As==01
  U1CTL  = CHAR;                  //init & release reset
    487a:	f2 40 10 00 	mov.b	#16,	&0x0078	;#0x0010
    487e:	78 00 
  
  U1TCTL = SSEL1 | TXEPT;        //use SMCLK 
    4880:	f2 40 21 00 	mov.b	#33,	&0x0079	;#0x0021
    4884:	79 00 
  U1RCTL = 0;
    4886:	c2 43 7a 00 	mov.b	#0,	&0x007a	;r3 As==00
  // 38400 @ SMCLK 1MHz
#define U1BR1_INIT        0
#define U1BR0_INIT        0x1B
#define U1MCTL_INIT       0x03
  
  U1BR1  = U1BR1_INIT;
    488a:	c2 43 7d 00 	mov.b	#0,	&0x007d	;r3 As==00
  U1BR0  = U1BR0_INIT;
    488e:	f2 40 1b 00 	mov.b	#27,	&0x007c	;#0x001b
    4892:	7c 00 
  U1MCTL = U1MCTL_INIT;
    4894:	f2 40 03 00 	mov.b	#3,	&0x007b	;#0x0003
    4898:	7b 00 

  delay(0x800);
    489a:	3f 40 00 08 	mov	#2048,	r15	;#0x0800
    489e:	b0 12 0c 48 	call	#0x480c	
  return 0;
    48a2:	0f 43       	clr	r15		
}
    48a4:	34 41       	pop	r4		
    48a6:	30 41       	ret			

000048a8 <uart1_putchar>:

int uart1_putchar(int c)
{
    48a8:	04 12       	push	r4		
    48aa:	04 41       	mov	r1,	r4	
    48ac:	24 53       	incd	r4		
    48ae:	21 83       	decd	r1		
    48b0:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
  U1TXBUF = c;
    48b4:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    48b8:	4f 4f       	mov.b	r15,	r15	
    48ba:	c2 4f 7f 00 	mov.b	r15,	&0x007f	
  while ((U1TCTL & TXEPT) != TXEPT);
    48be:	03 43       	nop			
    48c0:	5f 42 79 00 	mov.b	&0x0079,r15	
    48c4:	4f 4f       	mov.b	r15,	r15	
    48c6:	1f f3       	and	#1,	r15	;r3 As==01
    48c8:	0f 93       	tst	r15		
    48ca:	fa 27       	jz	$-10     	;abs 0x48c0
  return (unsigned char)c;
    48cc:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    48d0:	4f 4f       	mov.b	r15,	r15	
    48d2:	4f 4f       	mov.b	r15,	r15	
}
    48d4:	21 53       	incd	r1		
    48d6:	34 41       	pop	r4		
    48d8:	30 41       	ret			

000048da <putchar>:
/**************************************************/
/******************** PUT CHAR *********************/
/**************************************************/

int putchar(int c)
{
    48da:	04 12       	push	r4		
    48dc:	04 41       	mov	r1,	r4	
    48de:	24 53       	incd	r4		
    48e0:	21 83       	decd	r1		
    48e2:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
  return uart1_putchar(c);
    48e6:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    48ea:	b0 12 a8 48 	call	#0x48a8	
}
    48ee:	21 53       	incd	r1		
    48f0:	34 41       	pop	r4		
    48f2:	30 41       	ret			

000048f4 <start_encrypt>:
/******************** END EXPE*********************/
/**************************************************/

void
start_encrypt()
{
    48f4:	04 12       	push	r4		
    48f6:	04 41       	mov	r1,	r4	
    48f8:	24 53       	incd	r4		
  ;
}
    48fa:	34 41       	pop	r4		
    48fc:	30 41       	ret			

000048fe <start_decrypt>:
void
start_decrypt()
{
    48fe:	04 12       	push	r4		
    4900:	04 41       	mov	r1,	r4	
    4902:	24 53       	incd	r4		
  ;
}
    4904:	34 41       	pop	r4		
    4906:	30 41       	ret			

00004908 <end_expe>:


void
end_expe()
{
    4908:	04 12       	push	r4		
    490a:	04 41       	mov	r1,	r4	
    490c:	24 53       	incd	r4		
  ;
}
    490e:	34 41       	pop	r4		
    4910:	30 41       	ret			

00004912 <memcpy>:
    4912:	0b 12       	push	r11		
    4914:	0a 12       	push	r10		
    4916:	09 12       	push	r9		
    4918:	08 12       	push	r8		
    491a:	07 12       	push	r7		
    491c:	0d 93       	tst	r13		
    491e:	70 24       	jz	$+226    	;abs 0x4a00
    4920:	0f 9e       	cmp	r14,	r15	
    4922:	6e 24       	jz	$+222    	;abs 0x4a00
    4924:	34 2c       	jc	$+106    	;abs 0x498e
    4926:	0c 4e       	mov	r14,	r12	
    4928:	0c df       	bis	r15,	r12	
    492a:	1c f3       	and	#1,	r12	;r3 As==01
    492c:	1b 24       	jz	$+56     	;abs 0x4964
    492e:	0c 4e       	mov	r14,	r12	
    4930:	0c ef       	xor	r15,	r12	
    4932:	1c f3       	and	#1,	r12	;r3 As==01
    4934:	07 20       	jnz	$+16     	;abs 0x4944
    4936:	2d 93       	cmp	#2,	r13	;r3 As==10
    4938:	07 28       	jnc	$+16     	;abs 0x4948
    493a:	0b 4e       	mov	r14,	r11	
    493c:	1b f3       	and	#1,	r11	;r3 As==01
    493e:	2c 43       	mov	#2,	r12	;r3 As==10
    4940:	0c 8b       	sub	r11,	r12	
    4942:	03 3c       	jmp	$+8      	;abs 0x494a
    4944:	0c 4d       	mov	r13,	r12	
    4946:	01 3c       	jmp	$+4      	;abs 0x494a
    4948:	1c 43       	mov	#1,	r12	;r3 As==01
    494a:	0d 8c       	sub	r12,	r13	
    494c:	0a 4c       	mov	r12,	r10	
    494e:	09 4e       	mov	r14,	r9	
    4950:	0b 4f       	mov	r15,	r11	
    4952:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    4956:	1b 53       	inc	r11		
    4958:	3a 53       	add	#-1,	r10	;r3 As==11
    495a:	fb 23       	jnz	$-8      	;abs 0x4952
    495c:	0a 4f       	mov	r15,	r10	
    495e:	0a 5c       	add	r12,	r10	
    4960:	0e 5c       	add	r12,	r14	
    4962:	01 3c       	jmp	$+4      	;abs 0x4966
    4964:	0a 4f       	mov	r15,	r10	
    4966:	0b 4d       	mov	r13,	r11	
    4968:	12 c3       	clrc			
    496a:	0b 10       	rrc	r11		
    496c:	0b 24       	jz	$+24     	;abs 0x4984
    496e:	09 4b       	mov	r11,	r9	
    4970:	08 4e       	mov	r14,	r8	
    4972:	0c 4a       	mov	r10,	r12	
    4974:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    4978:	2c 53       	incd	r12		
    497a:	39 53       	add	#-1,	r9	;r3 As==11
    497c:	fb 23       	jnz	$-8      	;abs 0x4974
    497e:	0b 5b       	rla	r11		
    4980:	0e 5b       	add	r11,	r14	
    4982:	0a 5b       	add	r11,	r10	
    4984:	1d f3       	and	#1,	r13	;r3 As==01
    4986:	3c 24       	jz	$+122    	;abs 0x4a00
    4988:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    498c:	39 3c       	jmp	$+116    	;abs 0x4a00
    498e:	0e 5d       	add	r13,	r14	
    4990:	0c 4f       	mov	r15,	r12	
    4992:	0c 5d       	add	r13,	r12	
    4994:	0b 4c       	mov	r12,	r11	
    4996:	0b de       	bis	r14,	r11	
    4998:	1b f3       	and	#1,	r11	;r3 As==01
    499a:	1b 24       	jz	$+56     	;abs 0x49d2
    499c:	0b 4c       	mov	r12,	r11	
    499e:	0b ee       	xor	r14,	r11	
    49a0:	1b f3       	and	#1,	r11	;r3 As==01
    49a2:	06 20       	jnz	$+14     	;abs 0x49b0
    49a4:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    49a8:	03 28       	jnc	$+8      	;abs 0x49b0
    49aa:	0b 4e       	mov	r14,	r11	
    49ac:	1b f3       	and	#1,	r11	;r3 As==01
    49ae:	01 3c       	jmp	$+4      	;abs 0x49b2
    49b0:	0b 4d       	mov	r13,	r11	
    49b2:	0d 8b       	sub	r11,	r13	
    49b4:	09 4e       	mov	r14,	r9	
    49b6:	0a 4c       	mov	r12,	r10	
    49b8:	08 4b       	mov	r11,	r8	
    49ba:	08 8c       	sub	r12,	r8	
    49bc:	3a 53       	add	#-1,	r10	;r3 As==11
    49be:	39 53       	add	#-1,	r9	;r3 As==11
    49c0:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    49c4:	07 4a       	mov	r10,	r7	
    49c6:	07 58       	add	r8,	r7	
    49c8:	f9 23       	jnz	$-12     	;abs 0x49bc
    49ca:	3b e3       	inv	r11		
    49cc:	1b 53       	inc	r11		
    49ce:	0c 5b       	add	r11,	r12	
    49d0:	0e 5b       	add	r11,	r14	
    49d2:	0b 4d       	mov	r13,	r11	
    49d4:	12 c3       	clrc			
    49d6:	0b 10       	rrc	r11		
    49d8:	0e 24       	jz	$+30     	;abs 0x49f6
    49da:	0a 4b       	mov	r11,	r10	
    49dc:	08 4e       	mov	r14,	r8	
    49de:	09 4c       	mov	r12,	r9	
    49e0:	28 83       	decd	r8		
    49e2:	29 83       	decd	r9		
    49e4:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    49e8:	3a 53       	add	#-1,	r10	;r3 As==11
    49ea:	fa 23       	jnz	$-10     	;abs 0x49e0
    49ec:	0a 8b       	sub	r11,	r10	
    49ee:	0b 4a       	mov	r10,	r11	
    49f0:	0b 5b       	rla	r11		
    49f2:	0e 5b       	add	r11,	r14	
    49f4:	0c 5b       	add	r11,	r12	
    49f6:	1d f3       	and	#1,	r13	;r3 As==01
    49f8:	03 24       	jz	$+8      	;abs 0x4a00
    49fa:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    49fe:	ff ff 
    4a00:	37 41       	pop	r7		
    4a02:	38 41       	pop	r8		
    4a04:	39 41       	pop	r9		
    4a06:	3a 41       	pop	r10		
    4a08:	3b 41       	pop	r11		
    4a0a:	30 41       	ret			

00004a0c <_unexpected_>:
    4a0c:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	fc 40 fc 40 fc 40 fc 40 fc 40 fc 40 fc 40 fc 40     .@.@.@.@.@.@.@.@
    fff0:	fc 40 fc 40 fc 40 fc 40 fc 40 fc 40 fc 40 00 40     .@.@.@.@.@.@.@.@
