
led.elf:     file format elf32-msp430

SYMBOL TABLE:
00004000 l    d  .text	00000000 .text
00004962 l    d  .rodata	00000000 .rodata
00001100 l    d  .data	00000000 .data
00001130 l    d  .bss	00000000 .bss
00001230 l    d  .noinit	00000000 .noinit
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 LED64_tcalc.c
00004962 l     O .rodata	00000010 MixColMatrix
00004972 l     O .rodata	00000010 sbox
00004982 l     O .rodata	00000010 invMixColMatrix
00004992 l     O .rodata	00000010 invSbox
000040e8 l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 tools.c
00000000 l    df *ABS*	00000000 memcpy.c
0000482e g     F .text	0000001a putchar
00000057 g       *ABS*	00000000 __BCSCTL1
0000005a g       *ABS*	00000000 __CACTL2
00000174 g       *ABS*	00000000 __TACCR1
00000084 g       *ABS*	00000000 __ADC12MCTL4
00000030 g       *ABS*	00000000 __data_size
0000015a g       *ABS*	00000000 __ADC12MEM13
00000052 g       *ABS*	00000000 __I2CNDAT
000040e8  w      .text	00000000 __isr_14
00000128 g       *ABS*	00000000 __FCTL1
00000024 g       *ABS*	00000000 __P1IES
0000007b g       *ABS*	00000000 __U1MCTL
000001f6 g       *ABS*	00000000 __DMA2SZ
000040e8  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
00000076 g       *ABS*	00000000 __I2CDRW
0000007e g       *ABS*	00000000 __U1RXBUF
00000138 g       *ABS*	00000000 __OP2
00000076 g       *ABS*	00000000 __U0RXBUF
000001a4 g       *ABS*	00000000 __ADC12IFG
0000012e g       *ABS*	00000000 __TAIV
000001e6 g       *ABS*	00000000 __DMA0SZ
00000000 g       .vectors	00000000 _efartext
0000007c g       *ABS*	00000000 __U1BR0
00000130 g       *ABS*	00000000 __MPY
00000001 g       *ABS*	00000000 __IE2
0000013a g       *ABS*	00000000 __RESLO
00000136 g       *ABS*	00000000 __MACS
00000087 g       *ABS*	00000000 __ADC12MCTL7
0000002b g       *ABS*	00000000 __P2IFG
0000001a g       *ABS*	00000000 __P3DIR
000049a2 g       *ABS*	00000000 _etext
00000190 g       *ABS*	00000000 __TBR
0000001d g       *ABS*	00000000 __P4OUT
000001f4 g       *ABS*	00000000 __DMA2DA
00000100 g       *ABS*	00000000 __bss_size
00000081 g       *ABS*	00000000 __ADC12MCTL1
0000479e g     F .text	0000005e uart1_init
00000152 g       *ABS*	00000000 __ADC12MEM9
00004000  w      .text	00000000 __watchdog_support
000040e2  w      .text	00000000 __stop_progExec__
00004866 g     F .text	000000fa memcpy
000045f6 g     F .text	000000f0 invSCShRMCS
00000050 g       *ABS*	00000000 __I2CIE
0000002d g       *ABS*	00000000 __P2IE
00001130 g     O .bss	00000080 Table
000001e4 g       *ABS*	00000000 __DMA0DA
00000192 g       *ABS*	00000000 __TBCCR0
000040e8  w      .text	00000000 __isr_11
00000186 g       *ABS*	00000000 __TBCCTL2
0000485c g     F .text	0000000a end_expe
00000025 g       *ABS*	00000000 __P1IE
000001a0 g       *ABS*	00000000 __ADC12CTL0
00000072 g       *ABS*	00000000 __I2CDCTL
00000073 g       *ABS*	00000000 __U0MCTL
0000007a g       *ABS*	00000000 __U1RCTL
00000082 g       *ABS*	00000000 __ADC12MCTL2
0000019c g       *ABS*	00000000 __TBCCR5
00000035 g       *ABS*	00000000 __P6OUT
00000034 g       *ABS*	00000000 __P6IN
000001c8 g       *ABS*	00000000 __DAC12_0DAT
00000182 g       *ABS*	00000000 __TBCCTL0
0000019e g       *ABS*	00000000 __TBCCR6
000040e8  w      .text	00000000 __isr_5
000049a2 g       *ABS*	00000000 __data_load_start
000040e8 g       .text	00000000 __dtors_end
000001ea g       *ABS*	00000000 __DMA1SA
00000088 g       *ABS*	00000000 __ADC12MCTL8
00000166 g       *ABS*	00000000 __TACCTL2
000001f0 g       *ABS*	00000000 __DMA2CTL
0000436e g     F .text	00000096 BuildTableSCShRMCS
000011b0 g     O .bss	00000080 invTable
000040e8  w      .text	00000000 __isr_2
00000156 g       *ABS*	00000000 __ADC12MEM11
00000160 g       *ABS*	00000000 __TACTL
00000158 g       *ABS*	00000000 __ADC12MEM12
00000071 g       *ABS*	00000000 __I2CTCTL
0000012c g       *ABS*	00000000 __FCTL3
000040e8  w      .text	00000000 __isr_10
00000148 g       *ABS*	00000000 __ADC12MEM4
0000011a g       *ABS*	00000000 __I2CSA
0000002e g       *ABS*	00000000 __P2SEL
00000180 g       *ABS*	00000000 __TBCTL
0000008d g       *ABS*	00000000 __ADC12MCTL13
0000014c g       *ABS*	00000000 __ADC12MEM6
00000023 g       *ABS*	00000000 __P1IFG
0000013c g       *ABS*	00000000 __RESHI
00000072 g       *ABS*	00000000 __U0RCTL
00000172 g       *ABS*	00000000 __TACCR0
00000071 g       *ABS*	00000000 __U0TCTL
00000056 g       *ABS*	00000000 __DCOCTL
00000085 g       *ABS*	00000000 __ADC12MCTL5
00000003 g       *ABS*	00000000 __IFG2
00000005 g       *ABS*	00000000 __ME2
00001230 g     O .noinit	00000002 __wdt_clear_value
00000079 g       *ABS*	00000000 __U1TCTL
0000001b g       *ABS*	00000000 __P3SEL
000001e0 g       *ABS*	00000000 __DMA0CTL
000040e8  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
00000028 g       *ABS*	00000000 __P2IN
0000014e g       *ABS*	00000000 __ADC12MEM7
00000184 g       *ABS*	00000000 __TBCCTL1
0000005b g       *ABS*	00000000 __CAPD
00000075 g       *ABS*	00000000 __I2CSCLL
000040e8  w      .text	00000000 __isr_0
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
00004028  w      .text	00000000 __do_clear_bss
0000417c g     F .text	000000e6 AddKey
0000008f g       *ABS*	00000000 __ADC12MCTL15
00000021 g       *ABS*	00000000 __P1OUT
0000002c g       *ABS*	00000000 __P2IES
0000015c g       *ABS*	00000000 __ADC12MEM14
000040ec g     F .text	00000090 FieldMult
00000026 g       *ABS*	00000000 __P1SEL
00000198 g       *ABS*	00000000 __TBCCR3
00000080 g       *ABS*	00000000 __ADC12MCTL0
00000140 g       *ABS*	00000000 __ADC12MEM0
000046e6 g     F .text	0000007a invLEDRound
00000074 g       *ABS*	00000000 __U0BR0
00000051 g       *ABS*	00000000 __I2CIFG
00004960  w      .text	00000000 _unexpected_
000040e8  w      .text	00000000 __isr_8
0000014a g       *ABS*	00000000 __ADC12MEM5
00000070 g       *ABS*	00000000 __U0CTL
0000018a g       *ABS*	00000000 __TBCCTL4
00000073 g       *ABS*	00000000 __I2CPSC
0000008e g       *ABS*	00000000 __ADC12MCTL14
000040e8  w      .text	00000000 __isr_3
000001a6 g       *ABS*	00000000 __ADC12IE
000047fc g     F .text	00000032 uart1_putchar
00000144 g       *ABS*	00000000 __ADC12MEM2
00004404 g     F .text	000000ea SCShRMCS
000001ee g       *ABS*	00000000 __DMA1SZ
00000033 g       *ABS*	00000000 __P5SEL
00000030 g       *ABS*	00000000 __P5IN
00004000  w      .text	00000000 _reset_vector__
000040e8 g       .text	00000000 __ctors_start
000040e8  w      .text	00000000 __isr_12
00000036 g       *ABS*	00000000 __P6DIR
00000018 g       *ABS*	00000000 __P3IN
00004010  w      .text	00000000 __do_copy_data
00000150 g       *ABS*	00000000 __ADC12MEM8
00000142 g       *ABS*	00000000 __ADC12MEM1
00001130 g       .bss	00000000 __bss_start
0000007d g       *ABS*	00000000 __U1BR1
0000403e g     F .text	000000a4 main
00000176 g       *ABS*	00000000 __TACCR2
0000019a g       *ABS*	00000000 __TBCCR4
000040e8  w      .text	00000000 __isr_13
00000078 g       *ABS*	00000000 __U1CTL
000001e2 g       *ABS*	00000000 __DMA0SA
00000170 g       *ABS*	00000000 __TAR
00000124 g       *ABS*	00000000 __DMACTL1
0000001e g       *ABS*	00000000 __P4DIR
00000162 g       *ABS*	00000000 __TACCTL0
00010000 g       .vectors	00000000 _vectors_end
00000154 g       *ABS*	00000000 __ADC12MEM10
000001f2 g       *ABS*	00000000 __DMA2SA
0000002a g       *ABS*	00000000 __P2DIR
00000089 g       *ABS*	00000000 __ADC12MCTL9
0000008a g       *ABS*	00000000 __ADC12MCTL10
00004760 g     F .text	0000003e delay
00000032 g       *ABS*	00000000 __P5DIR
000001c2 g       *ABS*	00000000 __DAC12_1CTL
000001a2 g       *ABS*	00000000 __ADC12CTL1
000001a8 g       *ABS*	00000000 __ADC12IV
000001e8 g       *ABS*	00000000 __DMA1CTL
00000075 g       *ABS*	00000000 __U0BR1
000040e8  w      .text	00000000 __isr_9
0000018c g       *ABS*	00000000 __TBCCTL5
0000400c  w      .text	00000000 __init_stack
00000086 g       *ABS*	00000000 __ADC12MCTL6
00000188 g       *ABS*	00000000 __TBCCTL3
00000019 g       *ABS*	00000000 __P3OUT
000001ca g       *ABS*	00000000 __DAC12_1DAT
000040e8 g       .text	00000000 __dtors_start
000040e8  w      .text	00000000 __isr_6
000040e8 g       .text	00000000 __ctors_end
00000132 g       *ABS*	00000000 __MPYS
0000011c g       *ABS*	00000000 __I2CIV
00000004 g       *ABS*	00000000 __ME1
00003900 g       *ABS*	00000000 __stack
00000037 g       *ABS*	00000000 __P6SEL
000040e8  w      .text	00000000 __isr_1
0000008c g       *ABS*	00000000 __ADC12MCTL12
00001130 g       .data	00000000 _edata
00000077 g       *ABS*	00000000 __U0TXBUF
000044ee g     F .text	00000076 LEDRound
00001232 g       *ABS*	00000000 _end
00000194 g       *ABS*	00000000 __TBCCR1
0000011e g       *ABS*	00000000 __TBIV
000001c0 g       *ABS*	00000000 __DAC12_0CTL
00004848 g     F .text	0000000a start_encrypt
0000015e g       *ABS*	00000000 __ADC12MEM15
00000134 g       *ABS*	00000000 __MAC
00000058 g       *ABS*	00000000 __BCSCTL2
000040e2  w      .text	00000000 _endless_loop__
00000122 g       *ABS*	00000000 __DMACTL0
0000001f g       *ABS*	00000000 __P4SEL
00000196 g       *ABS*	00000000 __TBCCR2
00000022 g       *ABS*	00000000 __P1DIR
00000146 g       *ABS*	00000000 __ADC12MEM3
00000076 g       *ABS*	00000000 __I2CDRB
00000118 g       *ABS*	00000000 __I2COA
00000164 g       *ABS*	00000000 __TACCTL1
0000007f g       *ABS*	00000000 __U1TXBUF
00000055 g       *ABS*	00000000 __SVSCTL
00004010  w      .text	00000000 __low_level_init
00004852 g     F .text	0000000a start_decrypt
00001100 g       .data	00000000 __data_start
0000018e g       *ABS*	00000000 __TBCCTL6
00000074 g       *ABS*	00000000 __I2CSCLH
000001ec g       *ABS*	00000000 __DMA1DA
00000120 g       *ABS*	00000000 __WDTCTL
00000083 g       *ABS*	00000000 __ADC12MCTL3
00000000 g       *ABS*	00000000 __IE1
00004564 g     F .text	00000092 invBuildTableSCShRMCS
00000059 g       *ABS*	00000000 __CACTL1
00000020 g       *ABS*	00000000 __P1IN
0000001c g       *ABS*	00000000 __P4IN
0000008b g       *ABS*	00000000 __ADC12MCTL11
0000013e g       *ABS*	00000000 __SUMEXT
00000031 g       *ABS*	00000000 __P5OUT
00004262 g     F .text	0000010c AddConstants



Disassembly of section .text:

00004000 <__watchdog_support>:
    4000:	55 42 20 01 	mov.b	&0x0120,r5	
    4004:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
    4008:	82 45 30 12 	mov	r5,	&0x1230	

0000400c <__init_stack>:
    400c:	31 40 00 39 	mov	#14592,	r1	;#0x3900

00004010 <__do_copy_data>:
    4010:	3f 40 30 00 	mov	#48,	r15	;#0x0030
    4014:	0f 93       	tst	r15		
    4016:	08 24       	jz	$+18     	;abs 0x4028
    4018:	92 42 30 12 	mov	&0x1230,&0x0120	
    401c:	20 01 
    401e:	2f 83       	decd	r15		
    4020:	9f 4f a2 49 	mov	18850(r15),4352(r15);0x49a2(r15), 0x1100(r15)
    4024:	00 11 
    4026:	f8 23       	jnz	$-14     	;abs 0x4018

00004028 <__do_clear_bss>:
    4028:	3f 40 00 01 	mov	#256,	r15	;#0x0100
    402c:	0f 93       	tst	r15		
    402e:	07 24       	jz	$+16     	;abs 0x403e
    4030:	92 42 30 12 	mov	&0x1230,&0x0120	
    4034:	20 01 
    4036:	1f 83       	dec	r15		
    4038:	cf 43 30 11 	mov.b	#0,	4400(r15);r3 As==00, 0x1130(r15)
    403c:	f9 23       	jnz	$-12     	;abs 0x4030

0000403e <main>:



/************************************************************************************************/
int main(int argc, char*argv[])
{
    403e:	04 41       	mov	r1,	r4	
    4040:	24 53       	incd	r4		
    4042:	31 50 c8 ff 	add	#-56,	r1	;#0xffc8
    4046:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    404a:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	int i,j;

	u8 state[4][4];
	u8 keys[128/4];

	START_ENCRYPT();
    404e:	b0 12 48 48 	call	#0x4848	

	for(i = 0; i < 4; i++)
    4052:	84 43 c6 ff 	mov	#0,	-58(r4)	;r3 As==00, 0xffc6(r4)
    4056:	17 3c       	jmp	$+48     	;abs 0x4086
		for(j = 0; j < 4; j++)
    4058:	84 43 c8 ff 	mov	#0,	-56(r4)	;r3 As==00, 0xffc8(r4)
    405c:	0f 3c       	jmp	$+32     	;abs 0x407c
			state[i][j] = 0;
    405e:	1f 44 c6 ff 	mov	-58(r4),r15	;0xffc6(r4)
    4062:	0f 5f       	rla	r15		
    4064:	0f 5f       	rla	r15		
    4066:	3e 40 c6 ff 	mov	#-58,	r14	;#0xffc6
    406a:	0e 54       	add	r4,	r14	
    406c:	0f 5e       	add	r14,	r15	
    406e:	1f 54 c8 ff 	add	-56(r4),r15	;0xffc8(r4)
    4072:	2f 52       	add	#4,	r15	;r2 As==10
    4074:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
	u8 keys[128/4];

	START_ENCRYPT();

	for(i = 0; i < 4; i++)
		for(j = 0; j < 4; j++)
    4078:	94 53 c8 ff 	inc	-56(r4)	;0xffc8(r4)
    407c:	a4 92 c8 ff 	cmp	#4,	-56(r4)	;r2 As==10, 0xffc8(r4)
    4080:	ee 3b       	jl	$-34     	;abs 0x405e
	u8 state[4][4];
	u8 keys[128/4];

	START_ENCRYPT();

	for(i = 0; i < 4; i++)
    4082:	94 53 c6 ff 	inc	-58(r4)	;0xffc6(r4)
    4086:	a4 92 c6 ff 	cmp	#4,	-58(r4)	;r2 As==10, 0xffc6(r4)
    408a:	e6 3b       	jl	$-50     	;abs 0x4058
		for(j = 0; j < 4; j++)
			state[i][j] = 0;
	for(i=0; i < 32; i++) keys[i] = 0;
    408c:	84 43 c6 ff 	mov	#0,	-58(r4)	;r3 As==00, 0xffc6(r4)
    4090:	09 3c       	jmp	$+20     	;abs 0x40a4
    4092:	0f 44       	mov	r4,	r15	
    4094:	3f 50 da ff 	add	#-38,	r15	;#0xffda
    4098:	1f 54 c6 ff 	add	-58(r4),r15	;0xffc6(r4)
    409c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    40a0:	94 53 c6 ff 	inc	-58(r4)	;0xffc6(r4)
    40a4:	b4 90 20 00 	cmp	#32,	-58(r4)	;#0x0020, 0xffc6(r4)
    40a8:	c6 ff 
    40aa:	f3 3b       	jl	$-24     	;abs 0x4092
	
	
	BuildTableSCShRMCS();
    40ac:	b0 12 6e 43 	call	#0x436e	
	LEDRound(state, keys);
    40b0:	0e 44       	mov	r4,	r14	
    40b2:	3e 50 da ff 	add	#-38,	r14	;#0xffda
    40b6:	0f 44       	mov	r4,	r15	
    40b8:	3f 50 ca ff 	add	#-54,	r15	;#0xffca
    40bc:	b0 12 ee 44 	call	#0x44ee	
	  printf("\n");}
	
	printf("\n");
#endif
	
	START_DECRYPT();
    40c0:	b0 12 52 48 	call	#0x4852	

	invBuildTableSCShRMCS();
    40c4:	b0 12 64 45 	call	#0x4564	
	invLEDRound(state, keys);
    40c8:	0e 44       	mov	r4,	r14	
    40ca:	3e 50 da ff 	add	#-38,	r14	;#0xffda
    40ce:	0f 44       	mov	r4,	r15	
    40d0:	3f 50 ca ff 	add	#-54,	r15	;#0xffca
    40d4:	b0 12 e6 46 	call	#0x46e6	
			printf("%X ",state[i][j]);
		printf("\n");}
		
		printf("\n");
#endif
		END_EXPE();
    40d8:	b0 12 5c 48 	call	#0x485c	
	return 0;
    40dc:	0f 43       	clr	r15		
}
    40de:	31 50 38 00 	add	#56,	r1	;#0x0038

000040e2 <__stop_progExec__>:
    40e2:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    40e6:	fd 3f       	jmp	$-4      	;abs 0x40e2

000040e8 <__ctors_end>:
    40e8:	30 40 60 49 	br	#0x4960	

000040ec <FieldMult>:
};
static const u8 invSbox[16] = {5, 14, 15, 8, 12, 1, 2, 13,11,4,6,3,0,7,9,10};


 u8 FieldMult(u8 a, u8 b)
{
    40ec:	04 12       	push	r4		
    40ee:	04 41       	mov	r1,	r4	
    40f0:	24 53       	incd	r4		
    40f2:	31 82       	sub	#8,	r1	;r2 As==11
    40f4:	c4 4f fc ff 	mov.b	r15,	-4(r4)	;0xfffc(r4)
    40f8:	c4 4e fd ff 	mov.b	r14,	-3(r4)	;0xfffd(r4)
	const u8 ReductionPoly = 0x3;
    40fc:	f4 40 03 00 	mov.b	#3,	-6(r4)	;#0x0003, 0xfffa(r4)
    4100:	fa ff 
	u8 x = a, ret = 0;
    4102:	d4 44 fc ff 	mov.b	-4(r4),	-10(r4)	;0xfffc(r4), 0xfff6(r4)
    4106:	f6 ff 
    4108:	c4 43 f7 ff 	mov.b	#0,	-9(r4)	;r3 As==00, 0xfff7(r4)
	int i;
	for(i = 0; i < 4; i++) {
    410c:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4110:	2b 3c       	jmp	$+88     	;abs 0x4168
		if((b>>i)&1) ret ^= x;
    4112:	5f 44 fd ff 	mov.b	-3(r4),	r15	;0xfffd(r4)
    4116:	1e 44 f8 ff 	mov	-8(r4),	r14	;0xfff8(r4)
    411a:	4e 4e       	mov.b	r14,	r14	
    411c:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    4120:	4e 93       	tst.b	r14		
    4122:	04 24       	jz	$+10     	;abs 0x412c
    4124:	0f 11       	rra	r15		
    4126:	7e 53       	add.b	#-1,	r14	;r3 As==11
    4128:	4e 93       	tst.b	r14		
    412a:	fc 23       	jnz	$-6      	;abs 0x4124
    412c:	1f f3       	and	#1,	r15	;r3 As==01
    412e:	4f 4f       	mov.b	r15,	r15	
    4130:	4f 93       	tst.b	r15		
    4132:	03 24       	jz	$+8      	;abs 0x413a
    4134:	d4 e4 f6 ff 	xor.b	-10(r4),-9(r4)	;0xfff6(r4), 0xfff7(r4)
    4138:	f7 ff 
		if(x&0x8) {
    413a:	5f 44 f6 ff 	mov.b	-10(r4),r15	;0xfff6(r4)
    413e:	3f f2       	and	#8,	r15	;r2 As==11
    4140:	0f 93       	tst	r15		
    4142:	0a 24       	jz	$+22     	;abs 0x4158
			x <<= 1;
    4144:	5f 44 f6 ff 	mov.b	-10(r4),r15	;0xfff6(r4)
    4148:	4f 4f       	mov.b	r15,	r15	
    414a:	4f 5f       	rla.b	r15		
    414c:	c4 4f f6 ff 	mov.b	r15,	-10(r4)	;0xfff6(r4)
			x ^= ReductionPoly;
    4150:	d4 e4 fa ff 	xor.b	-6(r4),	-10(r4)	;0xfffa(r4), 0xfff6(r4)
    4154:	f6 ff 
    4156:	06 3c       	jmp	$+14     	;abs 0x4164
		}
		else x <<= 1;
    4158:	5f 44 f6 ff 	mov.b	-10(r4),r15	;0xfff6(r4)
    415c:	4f 4f       	mov.b	r15,	r15	
    415e:	4f 5f       	rla.b	r15		
    4160:	c4 4f f6 ff 	mov.b	r15,	-10(r4)	;0xfff6(r4)
 u8 FieldMult(u8 a, u8 b)
{
	const u8 ReductionPoly = 0x3;
	u8 x = a, ret = 0;
	int i;
	for(i = 0; i < 4; i++) {
    4164:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    4168:	a4 92 f8 ff 	cmp	#4,	-8(r4)	;r2 As==10, 0xfff8(r4)
    416c:	d2 3b       	jl	$-90     	;abs 0x4112
			x <<= 1;
			x ^= ReductionPoly;
		}
		else x <<= 1;
	}
	return ret&WORDFILTER;
    416e:	5f 44 f7 ff 	mov.b	-9(r4),	r15	;0xfff7(r4)
    4172:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
}
    4176:	31 52       	add	#8,	r1	;r2 As==11
    4178:	34 41       	pop	r4		
    417a:	30 41       	ret			

0000417c <AddKey>:
 * else use the second half of the key
 * 
 * The key bytes are added row wise, i.e., first row , then second row etc.
 * */
 void AddKey(u8 state[4][4], u8* keyBytes, int half)
{
    417c:	04 12       	push	r4		
    417e:	04 41       	mov	r1,	r4	
    4180:	24 53       	incd	r4		
    4182:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    4186:	84 4f f8 ff 	mov	r15,	-8(r4)	;0xfff8(r4)
    418a:	84 4e fa ff 	mov	r14,	-6(r4)	;0xfffa(r4)
    418e:	84 4d fc ff 	mov	r13,	-4(r4)	;0xfffc(r4)
	int i, j;
	if((half&1) == 0){
    4192:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    4196:	1f f3       	and	#1,	r15	;r3 As==01
    4198:	0f 93       	tst	r15		
    419a:	30 20       	jnz	$+98     	;abs 0x41fc
		for(i = 0; i < 4; i++)
    419c:	84 43 f4 ff 	mov	#0,	-12(r4)	;r3 As==00, 0xfff4(r4)
    41a0:	29 3c       	jmp	$+84     	;abs 0x41f4
			for(j = 0; j < 4; j++)
    41a2:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    41a6:	21 3c       	jmp	$+68     	;abs 0x41ea
				state[i][j] ^= keyBytes[4*i+j];
    41a8:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    41ac:	0f 5f       	rla	r15		
    41ae:	0f 5f       	rla	r15		
    41b0:	1d 44 f8 ff 	mov	-8(r4),	r13	;0xfff8(r4)
    41b4:	0d 5f       	add	r15,	r13	
    41b6:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    41ba:	0f 5f       	rla	r15		
    41bc:	0f 5f       	rla	r15		
    41be:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    41c2:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    41c6:	6e 4f       	mov.b	@r15,	r14	
    41c8:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    41cc:	0f 5f       	rla	r15		
    41ce:	0f 5f       	rla	r15		
    41d0:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    41d4:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    41d8:	6f 4f       	mov.b	@r15,	r15	
    41da:	4e ef       	xor.b	r15,	r14	
    41dc:	0f 4d       	mov	r13,	r15	
    41de:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    41e2:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
 void AddKey(u8 state[4][4], u8* keyBytes, int half)
{
	int i, j;
	if((half&1) == 0){
		for(i = 0; i < 4; i++)
			for(j = 0; j < 4; j++)
    41e6:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    41ea:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    41ee:	dc 3b       	jl	$-70     	;abs 0x41a8
 * */
 void AddKey(u8 state[4][4], u8* keyBytes, int half)
{
	int i, j;
	if((half&1) == 0){
		for(i = 0; i < 4; i++)
    41f0:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    41f4:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    41f8:	d4 3b       	jl	$-86     	;abs 0x41a2
    41fa:	2f 3c       	jmp	$+96     	;abs 0x425a
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j];
	}
	else{
		for(i = 0; i < 4; i++)
    41fc:	84 43 f4 ff 	mov	#0,	-12(r4)	;r3 As==00, 0xfff4(r4)
    4200:	29 3c       	jmp	$+84     	;abs 0x4254
			for(j = 0; j < 4; j++)
    4202:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4206:	21 3c       	jmp	$+68     	;abs 0x424a
				state[i][j] ^= keyBytes[4*i+j+((LED-64)>>2)];
    4208:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    420c:	0f 5f       	rla	r15		
    420e:	0f 5f       	rla	r15		
    4210:	1d 44 f8 ff 	mov	-8(r4),	r13	;0xfff8(r4)
    4214:	0d 5f       	add	r15,	r13	
    4216:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    421a:	0f 5f       	rla	r15		
    421c:	0f 5f       	rla	r15		
    421e:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    4222:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4226:	6e 4f       	mov.b	@r15,	r14	
    4228:	1f 44 f4 ff 	mov	-12(r4),r15	;0xfff4(r4)
    422c:	0f 5f       	rla	r15		
    422e:	0f 5f       	rla	r15		
    4230:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4234:	1f 54 fa ff 	add	-6(r4),	r15	;0xfffa(r4)
    4238:	6f 4f       	mov.b	@r15,	r15	
    423a:	4e ef       	xor.b	r15,	r14	
    423c:	0f 4d       	mov	r13,	r15	
    423e:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    4242:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j];
	}
	else{
		for(i = 0; i < 4; i++)
			for(j = 0; j < 4; j++)
    4246:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    424a:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    424e:	dc 3b       	jl	$-70     	;abs 0x4208
		for(i = 0; i < 4; i++)
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j];
	}
	else{
		for(i = 0; i < 4; i++)
    4250:	94 53 f4 ff 	inc	-12(r4)	;0xfff4(r4)
    4254:	a4 92 f4 ff 	cmp	#4,	-12(r4)	;r2 As==10, 0xfff4(r4)
    4258:	d4 3b       	jl	$-86     	;abs 0x4202
			for(j = 0; j < 4; j++)
				state[i][j] ^= keyBytes[4*i+j+((LED-64)>>2)];
	}
}
    425a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    425e:	34 41       	pop	r4		
    4260:	30 41       	ret			

00004262 <AddConstants>:

 void AddConstants(u8 state[4][4], int r)
{
    4262:	04 12       	push	r4		
    4264:	04 41       	mov	r1,	r4	
    4266:	24 53       	incd	r4		
    4268:	31 50 ca ff 	add	#-54,	r1	;#0xffca
    426c:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    4270:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	const u8 RC[48] = {
    4274:	0f 44       	mov	r4,	r15	
    4276:	3f 50 c9 ff 	add	#-55,	r15	;#0xffc9
    427a:	3e 40 00 11 	mov	#4352,	r14	;#0x1100
    427e:	3d 40 30 00 	mov	#48,	r13	;#0x0030
    4282:	b0 12 66 48 	call	#0x4866	
		0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B,
		0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05, 0x0B, 0x17, 0x2E,
		0x1C, 0x38, 0x31, 0x23, 0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A,
		0x34, 0x29, 0x12, 0x24, 0x08, 0x11, 0x22, 0x04
	};
	state[1][0] ^= 1;
    4286:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    428a:	2f 52       	add	#4,	r15	;r2 As==10
    428c:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    4290:	2e 52       	add	#4,	r14	;r2 As==10
    4292:	6e 4e       	mov.b	@r14,	r14	
    4294:	5e e3       	xor.b	#1,	r14	;r3 As==01
    4296:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	state[2][0] ^= 2;
    429a:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    429e:	3f 52       	add	#8,	r15	;r2 As==11
    42a0:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    42a4:	3e 52       	add	#8,	r14	;r2 As==11
    42a6:	6e 4e       	mov.b	@r14,	r14	
    42a8:	6e e3       	xor.b	#2,	r14	;r3 As==10
    42aa:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
	state[3][0] ^= 3;
    42ae:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    42b2:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    42b6:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    42ba:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    42be:	6e 4e       	mov.b	@r14,	r14	
    42c0:	7e e0 03 00 	xor.b	#3,	r14	;#0x0003
    42c4:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)

	u8 tmp = (RC[r] >> 3) & 7;
    42c8:	0f 44       	mov	r4,	r15	
    42ca:	3f 50 c9 ff 	add	#-55,	r15	;#0xffc9
    42ce:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    42d2:	6f 4f       	mov.b	@r15,	r15	
    42d4:	4f 4f       	mov.b	r15,	r15	
    42d6:	4f 4f       	mov.b	r15,	r15	
    42d8:	12 c3       	clrc			
    42da:	4f 10       	rrc.b	r15		
    42dc:	12 c3       	clrc			
    42de:	4f 10       	rrc.b	r15		
    42e0:	12 c3       	clrc			
    42e2:	4f 10       	rrc.b	r15		
    42e4:	4e 4f       	mov.b	r15,	r14	
    42e6:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    42ea:	c4 4e c8 ff 	mov.b	r14,	-56(r4)	;0xffc8(r4)
	state[0][1] ^= tmp;
    42ee:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    42f2:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    42f6:	4e 4f       	mov.b	r15,	r14	
    42f8:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    42fc:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4300:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
	state[2][1] ^= tmp;
    4304:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4308:	3f 52       	add	#8,	r15	;r2 As==11
    430a:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    430e:	3e 52       	add	#8,	r14	;r2 As==11
    4310:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    4314:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    4318:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
	tmp =  RC[r] & 7;
    431c:	0f 44       	mov	r4,	r15	
    431e:	3f 50 c9 ff 	add	#-55,	r15	;#0xffc9
    4322:	1f 54 fc ff 	add	-4(r4),	r15	;0xfffc(r4)
    4326:	6f 4f       	mov.b	@r15,	r15	
    4328:	4e 4f       	mov.b	r15,	r14	
    432a:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    432e:	c4 4e c8 ff 	mov.b	r14,	-56(r4)	;0xffc8(r4)
	state[1][1] ^= tmp;
    4332:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4336:	2f 52       	add	#4,	r15	;r2 As==10
    4338:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    433c:	2e 52       	add	#4,	r14	;r2 As==10
    433e:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    4342:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    4346:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
	state[3][1] ^= tmp;
    434a:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    434e:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    4352:	1e 44 fa ff 	mov	-6(r4),	r14	;0xfffa(r4)
    4356:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    435a:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    435e:	5e e4 c8 ff 	xor.b	-56(r4),r14	;0xffc8(r4)
    4362:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
}
    4366:	31 50 36 00 	add	#54,	r1	;#0x0036
    436a:	34 41       	pop	r4		
    436c:	30 41       	ret			

0000436e <BuildTableSCShRMCS>:

u16 Table[4][1<<4];
 void BuildTableSCShRMCS()
{
    436e:	04 12       	push	r4		
    4370:	04 41       	mov	r1,	r4	
    4372:	24 53       	incd	r4		
    4374:	31 82       	sub	#8,	r1	;r2 As==11
	int c, v, r;
	u16 tv;
	for(v = 0; v < (1<<4); v++)
    4376:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    437a:	3d 3c       	jmp	$+124    	;abs 0x43f6
	{
		for(c = 0; c < 4; c++)
    437c:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4380:	35 3c       	jmp	$+108    	;abs 0x43ec
		{ // compute the entry Table[c][v]
			tv = 0;
    4382:	84 43 fc ff 	mov	#0,	-4(r4)	;r3 As==00, 0xfffc(r4)
			for(r = 0; r < 4; r++)
    4386:	84 43 fa ff 	mov	#0,	-6(r4)	;r3 As==00, 0xfffa(r4)
    438a:	1d 3c       	jmp	$+60     	;abs 0x43c6
			{
				tv <<= 4;
    438c:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    4390:	0f 5f       	rla	r15		
    4392:	0f 5f       	rla	r15		
    4394:	0f 5f       	rla	r15		
    4396:	0f 5f       	rla	r15		
    4398:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
				tv |= (u16) FieldMult(MixColMatrix[r][c], sbox[v]);
    439c:	1f 44 f8 ff 	mov	-8(r4),	r15	;0xfff8(r4)
    43a0:	3f 50 72 49 	add	#18802,	r15	;#0x4972
    43a4:	6e 4f       	mov.b	@r15,	r14	
    43a6:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    43aa:	0f 5f       	rla	r15		
    43ac:	0f 5f       	rla	r15		
    43ae:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    43b2:	3f 50 62 49 	add	#18786,	r15	;#0x4962
    43b6:	6f 4f       	mov.b	@r15,	r15	
    43b8:	b0 12 ec 40 	call	#0x40ec	
    43bc:	4f 4f       	mov.b	r15,	r15	
    43be:	84 df fc ff 	bis	r15,	-4(r4)	;0xfffc(r4)
	for(v = 0; v < (1<<4); v++)
	{
		for(c = 0; c < 4; c++)
		{ // compute the entry Table[c][v]
			tv = 0;
			for(r = 0; r < 4; r++)
    43c2:	94 53 fa ff 	inc	-6(r4)		;0xfffa(r4)
    43c6:	a4 92 fa ff 	cmp	#4,	-6(r4)	;r2 As==10, 0xfffa(r4)
    43ca:	e0 3b       	jl	$-62     	;abs 0x438c
			{
				tv <<= 4;
				tv |= (u16) FieldMult(MixColMatrix[r][c], sbox[v]);
			}
			Table[c][v] = tv;
    43cc:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    43d0:	0f 5f       	rla	r15		
    43d2:	0f 5f       	rla	r15		
    43d4:	0f 5f       	rla	r15		
    43d6:	0f 5f       	rla	r15		
    43d8:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    43dc:	0f 5f       	rla	r15		
    43de:	3f 50 30 11 	add	#4400,	r15	;#0x1130
    43e2:	9f 44 fc ff 	mov	-4(r4),	0(r15)	;0xfffc(r4), 0x0000(r15)
    43e6:	00 00 
{
	int c, v, r;
	u16 tv;
	for(v = 0; v < (1<<4); v++)
	{
		for(c = 0; c < 4; c++)
    43e8:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    43ec:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    43f0:	c8 3b       	jl	$-110    	;abs 0x4382
u16 Table[4][1<<4];
 void BuildTableSCShRMCS()
{
	int c, v, r;
	u16 tv;
	for(v = 0; v < (1<<4); v++)
    43f2:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    43f6:	b4 90 10 00 	cmp	#16,	-8(r4)	;#0x0010, 0xfff8(r4)
    43fa:	f8 ff 
    43fc:	bf 3b       	jl	$-128    	;abs 0x437c
				tv |= (u16) FieldMult(MixColMatrix[r][c], sbox[v]);
			}
			Table[c][v] = tv;
		}
	}
}
    43fe:	31 52       	add	#8,	r1	;r2 As==11
    4400:	34 41       	pop	r4		
    4402:	30 41       	ret			

00004404 <SCShRMCS>:

 void SCShRMCS(u8 state[4][4])
{
    4404:	04 12       	push	r4		
    4406:	04 41       	mov	r1,	r4	
    4408:	24 53       	incd	r4		
    440a:	31 50 e8 ff 	add	#-24,	r1	;#0xffe8
    440e:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int c,r;
	u16 v;
	u8 os[4][4];
	memcpy(os, state, 4*4);
    4412:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    4416:	0f 44       	mov	r4,	r15	
    4418:	3f 50 ec ff 	add	#-20,	r15	;#0xffec
    441c:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    4420:	b0 12 66 48 	call	#0x4866	

	for(c = 0; c < 4; c++){
    4424:	84 43 e6 ff 	mov	#0,	-26(r4)	;r3 As==00, 0xffe6(r4)
    4428:	5b 3c       	jmp	$+184    	;abs 0x44e0
		v = 0;
    442a:	84 43 ea ff 	mov	#0,	-22(r4)	;r3 As==00, 0xffea(r4)
		for(r = 0; r < 4; r++)
    442e:	84 43 e8 ff 	mov	#0,	-24(r4)	;r3 As==00, 0xffe8(r4)
    4432:	29 3c       	jmp	$+84     	;abs 0x4486
			v ^= Table[r][os[r][(r+c)%4]];
    4434:	1f 44 e8 ff 	mov	-24(r4),r15	;0xffe8(r4)
    4438:	1f 54 e6 ff 	add	-26(r4),r15	;0xffe6(r4)
    443c:	3f f0 03 80 	and	#-32765,r15	;#0x8003
    4440:	0f 93       	tst	r15		
    4442:	04 34       	jge	$+10     	;abs 0x444c
    4444:	3f 53       	add	#-1,	r15	;r3 As==11
    4446:	3f d0 fc ff 	bis	#-4,	r15	;#0xfffc
    444a:	1f 53       	inc	r15		
    444c:	0e 4f       	mov	r15,	r14	
    444e:	1f 44 e8 ff 	mov	-24(r4),r15	;0xffe8(r4)
    4452:	0f 5f       	rla	r15		
    4454:	0f 5f       	rla	r15		
    4456:	3d 40 e6 ff 	mov	#-26,	r13	;#0xffe6
    445a:	0d 54       	add	r4,	r13	
    445c:	0f 5d       	add	r13,	r15	
    445e:	0f 5e       	add	r14,	r15	
    4460:	3f 50 06 00 	add	#6,	r15	;#0x0006
    4464:	6f 4f       	mov.b	@r15,	r15	
    4466:	4e 4f       	mov.b	r15,	r14	
    4468:	1f 44 e8 ff 	mov	-24(r4),r15	;0xffe8(r4)
    446c:	0f 5f       	rla	r15		
    446e:	0f 5f       	rla	r15		
    4470:	0f 5f       	rla	r15		
    4472:	0f 5f       	rla	r15		
    4474:	0f 5e       	add	r14,	r15	
    4476:	0f 5f       	rla	r15		
    4478:	3f 50 30 11 	add	#4400,	r15	;#0x1130
    447c:	2f 4f       	mov	@r15,	r15	
    447e:	84 ef ea ff 	xor	r15,	-22(r4)	;0xffea(r4)
	u8 os[4][4];
	memcpy(os, state, 4*4);

	for(c = 0; c < 4; c++){
		v = 0;
		for(r = 0; r < 4; r++)
    4482:	94 53 e8 ff 	inc	-24(r4)	;0xffe8(r4)
    4486:	a4 92 e8 ff 	cmp	#4,	-24(r4)	;r2 As==10, 0xffe8(r4)
    448a:	d4 3b       	jl	$-86     	;abs 0x4434
			v ^= Table[r][os[r][(r+c)%4]];

		for(r = 1; r <= 4; r++){
    448c:	94 43 e8 ff 	mov	#1,	-24(r4)	;r3 As==01, 0xffe8(r4)
    4490:	21 3c       	jmp	$+68     	;abs 0x44d4
			state[4-r][c] = (u8)v & WORDFILTER;
    4492:	2f 42       	mov	#4,	r15	;r2 As==10
    4494:	1f 84 e8 ff 	sub	-24(r4),r15	;0xffe8(r4)
    4498:	0f 5f       	rla	r15		
    449a:	0f 5f       	rla	r15		
    449c:	1d 44 fc ff 	mov	-4(r4),	r13	;0xfffc(r4)
    44a0:	0d 5f       	add	r15,	r13	
    44a2:	1f 44 ea ff 	mov	-22(r4),r15	;0xffea(r4)
    44a6:	4f 4f       	mov.b	r15,	r15	
    44a8:	4e 4f       	mov.b	r15,	r14	
    44aa:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    44ae:	0f 4d       	mov	r13,	r15	
    44b0:	1f 54 e6 ff 	add	-26(r4),r15	;0xffe6(r4)
    44b4:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
			v >>= 4;
    44b8:	1f 44 ea ff 	mov	-22(r4),r15	;0xffea(r4)
    44bc:	12 c3       	clrc			
    44be:	0f 10       	rrc	r15		
    44c0:	12 c3       	clrc			
    44c2:	0f 10       	rrc	r15		
    44c4:	12 c3       	clrc			
    44c6:	0f 10       	rrc	r15		
    44c8:	12 c3       	clrc			
    44ca:	0f 10       	rrc	r15		
    44cc:	84 4f ea ff 	mov	r15,	-22(r4)	;0xffea(r4)
	for(c = 0; c < 4; c++){
		v = 0;
		for(r = 0; r < 4; r++)
			v ^= Table[r][os[r][(r+c)%4]];

		for(r = 1; r <= 4; r++){
    44d0:	94 53 e8 ff 	inc	-24(r4)	;0xffe8(r4)
    44d4:	b4 90 05 00 	cmp	#5,	-24(r4)	;#0x0005, 0xffe8(r4)
    44d8:	e8 ff 
    44da:	db 3b       	jl	$-72     	;abs 0x4492
	int c,r;
	u16 v;
	u8 os[4][4];
	memcpy(os, state, 4*4);

	for(c = 0; c < 4; c++){
    44dc:	94 53 e6 ff 	inc	-26(r4)	;0xffe6(r4)
    44e0:	a4 92 e6 ff 	cmp	#4,	-26(r4)	;r2 As==10, 0xffe6(r4)
    44e4:	a2 3b       	jl	$-186    	;abs 0x442a
		for(r = 1; r <= 4; r++){
			state[4-r][c] = (u8)v & WORDFILTER;
			v >>= 4;
		}
	}
}
    44e6:	31 50 18 00 	add	#24,	r1	;#0x0018
    44ea:	34 41       	pop	r4		
    44ec:	30 41       	ret			

000044ee <LEDRound>:

 void LEDRound(u8 state[4][4], u8* keyBytes)
{
    44ee:	04 12       	push	r4		
    44f0:	04 41       	mov	r1,	r4	
    44f2:	24 53       	incd	r4		
    44f4:	31 82       	sub	#8,	r1	;r2 As==11
    44f6:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    44fa:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	int i,j;
	AddKey(state, keyBytes, 0);
    44fe:	0d 43       	clr	r13		
    4500:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    4504:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4508:	b0 12 7c 41 	call	#0x417c	
	for(i = 0; i < RN/4; i++){
    450c:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4510:	23 3c       	jmp	$+72     	;abs 0x4558
		for(j = 0; j < 4; j++)
    4512:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4516:	11 3c       	jmp	$+36     	;abs 0x453a
		{
			AddConstants(state, i*4+j);
    4518:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    451c:	0f 5f       	rla	r15		
    451e:	0f 5f       	rla	r15		
    4520:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    4524:	0e 4f       	mov	r15,	r14	
    4526:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    452a:	b0 12 62 42 	call	#0x4262	
			SCShRMCS(state);
    452e:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4532:	b0 12 04 44 	call	#0x4404	
 void LEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	AddKey(state, keyBytes, 0);
	for(i = 0; i < RN/4; i++){
		for(j = 0; j < 4; j++)
    4536:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    453a:	a4 92 f8 ff 	cmp	#4,	-8(r4)	;r2 As==10, 0xfff8(r4)
    453e:	ec 3b       	jl	$-38     	;abs 0x4518
		{
			AddConstants(state, i*4+j);
			SCShRMCS(state);
		}
		AddKey(state, keyBytes, i+1);
    4540:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    4544:	1f 53       	inc	r15		
    4546:	0d 4f       	mov	r15,	r13	
    4548:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    454c:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4550:	b0 12 7c 41 	call	#0x417c	

 void LEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	AddKey(state, keyBytes, 0);
	for(i = 0; i < RN/4; i++){
    4554:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    4558:	b4 92 f6 ff 	cmp	#8,	-10(r4)	;r2 As==11, 0xfff6(r4)
    455c:	da 3b       	jl	$-74     	;abs 0x4512
			AddConstants(state, i*4+j);
			SCShRMCS(state);
		}
		AddKey(state, keyBytes, i+1);
	}
}
    455e:	31 52       	add	#8,	r1	;r2 As==11
    4560:	34 41       	pop	r4		
    4562:	30 41       	ret			

00004564 <invBuildTableSCShRMCS>:

/************************************************************************************************/

u16 invTable[4][1<<4];
 void invBuildTableSCShRMCS()
{
    4564:	04 12       	push	r4		
    4566:	04 41       	mov	r1,	r4	
    4568:	24 53       	incd	r4		
    456a:	31 82       	sub	#8,	r1	;r2 As==11
	int c, v, r;
	u16 tv;
	for(v = 0; v < (1<<4); v++)
    456c:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4570:	3b 3c       	jmp	$+120    	;abs 0x45e8
	{
		for(c = 0; c < 4; c++)
    4572:	84 43 f6 ff 	mov	#0,	-10(r4)	;r3 As==00, 0xfff6(r4)
    4576:	33 3c       	jmp	$+104    	;abs 0x45de
		{ // compute the entry Table[c][v]
			tv = 0;
    4578:	84 43 fc ff 	mov	#0,	-4(r4)	;r3 As==00, 0xfffc(r4)
			for(r = 0; r < 4; r++)
    457c:	84 43 fa ff 	mov	#0,	-6(r4)	;r3 As==00, 0xfffa(r4)
    4580:	1b 3c       	jmp	$+56     	;abs 0x45b8
			{
				tv <<= 4;
    4582:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    4586:	0f 5f       	rla	r15		
    4588:	0f 5f       	rla	r15		
    458a:	0f 5f       	rla	r15		
    458c:	0f 5f       	rla	r15		
    458e:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
				tv |= (u16) FieldMult(invMixColMatrix[r][c], v);
    4592:	1f 44 f8 ff 	mov	-8(r4),	r15	;0xfff8(r4)
    4596:	4e 4f       	mov.b	r15,	r14	
    4598:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    459c:	0f 5f       	rla	r15		
    459e:	0f 5f       	rla	r15		
    45a0:	1f 54 f6 ff 	add	-10(r4),r15	;0xfff6(r4)
    45a4:	3f 50 82 49 	add	#18818,	r15	;#0x4982
    45a8:	6f 4f       	mov.b	@r15,	r15	
    45aa:	b0 12 ec 40 	call	#0x40ec	
    45ae:	4f 4f       	mov.b	r15,	r15	
    45b0:	84 df fc ff 	bis	r15,	-4(r4)	;0xfffc(r4)
	for(v = 0; v < (1<<4); v++)
	{
		for(c = 0; c < 4; c++)
		{ // compute the entry Table[c][v]
			tv = 0;
			for(r = 0; r < 4; r++)
    45b4:	94 53 fa ff 	inc	-6(r4)		;0xfffa(r4)
    45b8:	a4 92 fa ff 	cmp	#4,	-6(r4)	;r2 As==10, 0xfffa(r4)
    45bc:	e2 3b       	jl	$-58     	;abs 0x4582
			{
				tv <<= 4;
				tv |= (u16) FieldMult(invMixColMatrix[r][c], v);
			}
			invTable[c][v] = tv;
    45be:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    45c2:	0f 5f       	rla	r15		
    45c4:	0f 5f       	rla	r15		
    45c6:	0f 5f       	rla	r15		
    45c8:	0f 5f       	rla	r15		
    45ca:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    45ce:	0f 5f       	rla	r15		
    45d0:	3f 50 b0 11 	add	#4528,	r15	;#0x11b0
    45d4:	9f 44 fc ff 	mov	-4(r4),	0(r15)	;0xfffc(r4), 0x0000(r15)
    45d8:	00 00 
{
	int c, v, r;
	u16 tv;
	for(v = 0; v < (1<<4); v++)
	{
		for(c = 0; c < 4; c++)
    45da:	94 53 f6 ff 	inc	-10(r4)	;0xfff6(r4)
    45de:	a4 92 f6 ff 	cmp	#4,	-10(r4)	;r2 As==10, 0xfff6(r4)
    45e2:	ca 3b       	jl	$-106    	;abs 0x4578
u16 invTable[4][1<<4];
 void invBuildTableSCShRMCS()
{
	int c, v, r;
	u16 tv;
	for(v = 0; v < (1<<4); v++)
    45e4:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    45e8:	b4 90 10 00 	cmp	#16,	-8(r4)	;#0x0010, 0xfff8(r4)
    45ec:	f8 ff 
    45ee:	c1 3b       	jl	$-124    	;abs 0x4572
				tv |= (u16) FieldMult(invMixColMatrix[r][c], v);
			}
			invTable[c][v] = tv;
		}
	}
}
    45f0:	31 52       	add	#8,	r1	;r2 As==11
    45f2:	34 41       	pop	r4		
    45f4:	30 41       	ret			

000045f6 <invSCShRMCS>:

 void invSCShRMCS(u8 state[4][4])
{
    45f6:	04 12       	push	r4		
    45f8:	04 41       	mov	r1,	r4	
    45fa:	24 53       	incd	r4		
    45fc:	31 50 e8 ff 	add	#-24,	r1	;#0xffe8
    4600:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
	int c,r;
	u16 v;
	u8 os[4][4];
	memcpy(os, state, 4*4);
    4604:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    4608:	0f 44       	mov	r4,	r15	
    460a:	3f 50 ec ff 	add	#-20,	r15	;#0xffec
    460e:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    4612:	b0 12 66 48 	call	#0x4866	

	for(c = 0; c < 4; c++){
    4616:	84 43 e6 ff 	mov	#0,	-26(r4)	;r3 As==00, 0xffe6(r4)
    461a:	5e 3c       	jmp	$+190    	;abs 0x46d8
		v = 0;
    461c:	84 43 ea ff 	mov	#0,	-22(r4)	;r3 As==00, 0xffea(r4)
		for(r = 0; r < 4; r++)
    4620:	84 43 e8 ff 	mov	#0,	-24(r4)	;r3 As==00, 0xffe8(r4)
    4624:	1d 3c       	jmp	$+60     	;abs 0x4660
			v ^= invTable[r][os[r][c]];
    4626:	1f 44 e8 ff 	mov	-24(r4),r15	;0xffe8(r4)
    462a:	0f 5f       	rla	r15		
    462c:	0f 5f       	rla	r15		
    462e:	3e 40 e6 ff 	mov	#-26,	r14	;#0xffe6
    4632:	0e 54       	add	r4,	r14	
    4634:	0f 5e       	add	r14,	r15	
    4636:	1f 54 e6 ff 	add	-26(r4),r15	;0xffe6(r4)
    463a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    463e:	6f 4f       	mov.b	@r15,	r15	
    4640:	4e 4f       	mov.b	r15,	r14	
    4642:	1f 44 e8 ff 	mov	-24(r4),r15	;0xffe8(r4)
    4646:	0f 5f       	rla	r15		
    4648:	0f 5f       	rla	r15		
    464a:	0f 5f       	rla	r15		
    464c:	0f 5f       	rla	r15		
    464e:	0f 5e       	add	r14,	r15	
    4650:	0f 5f       	rla	r15		
    4652:	3f 50 b0 11 	add	#4528,	r15	;#0x11b0
    4656:	2f 4f       	mov	@r15,	r15	
    4658:	84 ef ea ff 	xor	r15,	-22(r4)	;0xffea(r4)
	u8 os[4][4];
	memcpy(os, state, 4*4);

	for(c = 0; c < 4; c++){
		v = 0;
		for(r = 0; r < 4; r++)
    465c:	94 53 e8 ff 	inc	-24(r4)	;0xffe8(r4)
    4660:	a4 92 e8 ff 	cmp	#4,	-24(r4)	;r2 As==10, 0xffe8(r4)
    4664:	e0 3b       	jl	$-62     	;abs 0x4626
			v ^= invTable[r][os[r][c]];

		for(r = 1; r <= 4; r++){
    4666:	94 43 e8 ff 	mov	#1,	-24(r4)	;r3 As==01, 0xffe8(r4)
    466a:	30 3c       	jmp	$+98     	;abs 0x46cc
			state[4-r][(c+(4-r))%4] = invSbox[(u8)v & WORDFILTER];
    466c:	2f 42       	mov	#4,	r15	;r2 As==10
    466e:	1f 84 e8 ff 	sub	-24(r4),r15	;0xffe8(r4)
    4672:	0f 5f       	rla	r15		
    4674:	0f 5f       	rla	r15		
    4676:	1c 44 fc ff 	mov	-4(r4),	r12	;0xfffc(r4)
    467a:	0c 5f       	add	r15,	r12	
    467c:	2f 42       	mov	#4,	r15	;r2 As==10
    467e:	1f 84 e8 ff 	sub	-24(r4),r15	;0xffe8(r4)
    4682:	1f 54 e6 ff 	add	-26(r4),r15	;0xffe6(r4)
    4686:	3f f0 03 80 	and	#-32765,r15	;#0x8003
    468a:	0f 93       	tst	r15		
    468c:	04 34       	jge	$+10     	;abs 0x4696
    468e:	3f 53       	add	#-1,	r15	;r3 As==11
    4690:	3f d0 fc ff 	bis	#-4,	r15	;#0xfffc
    4694:	1f 53       	inc	r15		
    4696:	0d 4f       	mov	r15,	r13	
    4698:	1f 44 ea ff 	mov	-22(r4),r15	;0xffea(r4)
    469c:	4f 4f       	mov.b	r15,	r15	
    469e:	4f 4f       	mov.b	r15,	r15	
    46a0:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    46a4:	5e 4f 92 49 	mov.b	18834(r15),r14	;0x4992(r15)
    46a8:	0f 4c       	mov	r12,	r15	
    46aa:	0f 5d       	add	r13,	r15	
    46ac:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
			v >>= 4;
    46b0:	1f 44 ea ff 	mov	-22(r4),r15	;0xffea(r4)
    46b4:	12 c3       	clrc			
    46b6:	0f 10       	rrc	r15		
    46b8:	12 c3       	clrc			
    46ba:	0f 10       	rrc	r15		
    46bc:	12 c3       	clrc			
    46be:	0f 10       	rrc	r15		
    46c0:	12 c3       	clrc			
    46c2:	0f 10       	rrc	r15		
    46c4:	84 4f ea ff 	mov	r15,	-22(r4)	;0xffea(r4)
	for(c = 0; c < 4; c++){
		v = 0;
		for(r = 0; r < 4; r++)
			v ^= invTable[r][os[r][c]];

		for(r = 1; r <= 4; r++){
    46c8:	94 53 e8 ff 	inc	-24(r4)	;0xffe8(r4)
    46cc:	b4 90 05 00 	cmp	#5,	-24(r4)	;#0x0005, 0xffe8(r4)
    46d0:	e8 ff 
    46d2:	cc 3b       	jl	$-102    	;abs 0x466c
	int c,r;
	u16 v;
	u8 os[4][4];
	memcpy(os, state, 4*4);

	for(c = 0; c < 4; c++){
    46d4:	94 53 e6 ff 	inc	-26(r4)	;0xffe6(r4)
    46d8:	a4 92 e6 ff 	cmp	#4,	-26(r4)	;r2 As==10, 0xffe6(r4)
    46dc:	9f 3b       	jl	$-192    	;abs 0x461c
		for(r = 1; r <= 4; r++){
			state[4-r][(c+(4-r))%4] = invSbox[(u8)v & WORDFILTER];
			v >>= 4;
		}
	}
}
    46de:	31 50 18 00 	add	#24,	r1	;#0x0018
    46e2:	34 41       	pop	r4		
    46e4:	30 41       	ret			

000046e6 <invLEDRound>:

 void invLEDRound(u8 state[4][4], u8* keyBytes)
{
    46e6:	04 12       	push	r4		
    46e8:	04 41       	mov	r1,	r4	
    46ea:	24 53       	incd	r4		
    46ec:	31 82       	sub	#8,	r1	;r2 As==11
    46ee:	84 4f fa ff 	mov	r15,	-6(r4)	;0xfffa(r4)
    46f2:	84 4e fc ff 	mov	r14,	-4(r4)	;0xfffc(r4)
	int i,j;
	for(i = (RN/4)-1; i >=0; i--)
    46f6:	b4 40 07 00 	mov	#7,	-10(r4)	;#0x0007, 0xfff6(r4)
    46fa:	f6 ff 
    46fc:	24 3c       	jmp	$+74     	;abs 0x4746
	{
		AddKey(state, keyBytes, i+1);
    46fe:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    4702:	1f 53       	inc	r15		
    4704:	0d 4f       	mov	r15,	r13	
    4706:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    470a:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    470e:	b0 12 7c 41 	call	#0x417c	
		for(j = 3; j >= 0; j--)
    4712:	b4 40 03 00 	mov	#3,	-8(r4)	;#0x0003, 0xfff8(r4)
    4716:	f8 ff 
    4718:	11 3c       	jmp	$+36     	;abs 0x473c
		{
			invSCShRMCS(state);
    471a:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    471e:	b0 12 f6 45 	call	#0x45f6	
			AddConstants(state, i*4+j);
    4722:	1f 44 f6 ff 	mov	-10(r4),r15	;0xfff6(r4)
    4726:	0f 5f       	rla	r15		
    4728:	0f 5f       	rla	r15		
    472a:	1f 54 f8 ff 	add	-8(r4),	r15	;0xfff8(r4)
    472e:	0e 4f       	mov	r15,	r14	
    4730:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4734:	b0 12 62 42 	call	#0x4262	
{
	int i,j;
	for(i = (RN/4)-1; i >=0; i--)
	{
		AddKey(state, keyBytes, i+1);
		for(j = 3; j >= 0; j--)
    4738:	b4 53 f8 ff 	add	#-1,	-8(r4)	;r3 As==11, 0xfff8(r4)
    473c:	84 93 f8 ff 	tst	-8(r4)		;0xfff8(r4)
    4740:	ec 37       	jge	$-38     	;abs 0x471a
}

 void invLEDRound(u8 state[4][4], u8* keyBytes)
{
	int i,j;
	for(i = (RN/4)-1; i >=0; i--)
    4742:	b4 53 f6 ff 	add	#-1,	-10(r4)	;r3 As==11, 0xfff6(r4)
    4746:	84 93 f6 ff 	tst	-10(r4)	;0xfff6(r4)
    474a:	d9 37       	jge	$-76     	;abs 0x46fe
		{
			invSCShRMCS(state);
			AddConstants(state, i*4+j);
		}
	}
	AddKey(state, keyBytes, 0);
    474c:	0d 43       	clr	r13		
    474e:	1e 44 fc ff 	mov	-4(r4),	r14	;0xfffc(r4)
    4752:	1f 44 fa ff 	mov	-6(r4),	r15	;0xfffa(r4)
    4756:	b0 12 7c 41 	call	#0x417c	
}
    475a:	31 52       	add	#8,	r1	;r2 As==11
    475c:	34 41       	pop	r4		
    475e:	30 41       	ret			

00004760 <delay>:
/**************************************************/
/********************* DELAY **********************/
/**************************************************/

void delay(unsigned int d) 
{
    4760:	04 12       	push	r4		
    4762:	04 41       	mov	r1,	r4	
    4764:	24 53       	incd	r4		
    4766:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    476a:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
  unsigned int i,j;
  for(j=0; j < 0xff; j++)
    476e:	84 43 fa ff 	mov	#0,	-6(r4)	;r3 As==00, 0xfffa(r4)
    4772:	0d 3c       	jmp	$+28     	;abs 0x478e
    {
      for (i = 0; i<d; i++) 
    4774:	84 43 f8 ff 	mov	#0,	-8(r4)	;r3 As==00, 0xfff8(r4)
    4778:	04 3c       	jmp	$+10     	;abs 0x4782
	{
	  nop();
    477a:	03 43       	nop			
	  nop();
    477c:	03 43       	nop			
void delay(unsigned int d) 
{
  unsigned int i,j;
  for(j=0; j < 0xff; j++)
    {
      for (i = 0; i<d; i++) 
    477e:	94 53 f8 ff 	inc	-8(r4)		;0xfff8(r4)
    4782:	94 94 fc ff 	cmp	-4(r4),	-8(r4)	;0xfffc(r4), 0xfff8(r4)
    4786:	f8 ff 
    4788:	f8 2b       	jnc	$-14     	;abs 0x477a
/**************************************************/

void delay(unsigned int d) 
{
  unsigned int i,j;
  for(j=0; j < 0xff; j++)
    478a:	94 53 fa ff 	inc	-6(r4)		;0xfffa(r4)
    478e:	b4 90 ff 00 	cmp	#255,	-6(r4)	;#0x00ff, 0xfffa(r4)
    4792:	fa ff 
    4794:	ef 2b       	jnc	$-32     	;abs 0x4774
	{
	  nop();
	  nop();
	}
    }
}
    4796:	31 50 06 00 	add	#6,	r1	;#0x0006
    479a:	34 41       	pop	r4		
    479c:	30 41       	ret			

0000479e <uart1_init>:

#define UART1_BIT_RX (1 << UART1_PIN_RX)
#define UART1_BIT_TX (1 << UART1_PIN_TX)

int uart1_init()
{
    479e:	04 12       	push	r4		
    47a0:	04 41       	mov	r1,	r4	
    47a2:	24 53       	incd	r4		

  WDTCTL = WDTPW + WDTHOLD;
    47a4:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    47a8:	20 01 

  P1IE   = 0x00;        // Interrupt enable
    47aa:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00
  P2IE   = 0x00;        // 0:disable 1:enable
    47ae:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00

  //Init of MSP430 Usart1 pins
  P3SEL |= (UART1_BIT_RX | UART1_BIT_TX);
    47b2:	5f 42 1b 00 	mov.b	&0x001b,r15	
    47b6:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    47ba:	c2 4f 1b 00 	mov.b	r15,	&0x001b	

  //Init of USART1 Module
  U1ME  |= UTXE1|URXE1;           //Enable USART1 transmiter and receiver (UART mode)
    47be:	5f 42 05 00 	mov.b	&0x0005,r15	
    47c2:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    47c6:	c2 4f 05 00 	mov.b	r15,	&0x0005	
  
  U1CTL  = SWRST;                 //reset
    47ca:	d2 43 78 00 	mov.b	#1,	&0x0078	;r3 As==01
  U1CTL  = CHAR;                  //init & release reset
    47ce:	f2 40 10 00 	mov.b	#16,	&0x0078	;#0x0010
    47d2:	78 00 
  
  U1TCTL = SSEL1 | TXEPT;        //use SMCLK 
    47d4:	f2 40 21 00 	mov.b	#33,	&0x0079	;#0x0021
    47d8:	79 00 
  U1RCTL = 0;
    47da:	c2 43 7a 00 	mov.b	#0,	&0x007a	;r3 As==00
  // 38400 @ SMCLK 1MHz
#define U1BR1_INIT        0
#define U1BR0_INIT        0x1B
#define U1MCTL_INIT       0x03
  
  U1BR1  = U1BR1_INIT;
    47de:	c2 43 7d 00 	mov.b	#0,	&0x007d	;r3 As==00
  U1BR0  = U1BR0_INIT;
    47e2:	f2 40 1b 00 	mov.b	#27,	&0x007c	;#0x001b
    47e6:	7c 00 
  U1MCTL = U1MCTL_INIT;
    47e8:	f2 40 03 00 	mov.b	#3,	&0x007b	;#0x0003
    47ec:	7b 00 

  delay(0x800);
    47ee:	3f 40 00 08 	mov	#2048,	r15	;#0x0800
    47f2:	b0 12 60 47 	call	#0x4760	
  return 0;
    47f6:	0f 43       	clr	r15		
}
    47f8:	34 41       	pop	r4		
    47fa:	30 41       	ret			

000047fc <uart1_putchar>:

int uart1_putchar(int c)
{
    47fc:	04 12       	push	r4		
    47fe:	04 41       	mov	r1,	r4	
    4800:	24 53       	incd	r4		
    4802:	21 83       	decd	r1		
    4804:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
  U1TXBUF = c;
    4808:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    480c:	4f 4f       	mov.b	r15,	r15	
    480e:	c2 4f 7f 00 	mov.b	r15,	&0x007f	
  while ((U1TCTL & TXEPT) != TXEPT);
    4812:	03 43       	nop			
    4814:	5f 42 79 00 	mov.b	&0x0079,r15	
    4818:	4f 4f       	mov.b	r15,	r15	
    481a:	1f f3       	and	#1,	r15	;r3 As==01
    481c:	0f 93       	tst	r15		
    481e:	fa 27       	jz	$-10     	;abs 0x4814
  return (unsigned char)c;
    4820:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    4824:	4f 4f       	mov.b	r15,	r15	
    4826:	4f 4f       	mov.b	r15,	r15	
}
    4828:	21 53       	incd	r1		
    482a:	34 41       	pop	r4		
    482c:	30 41       	ret			

0000482e <putchar>:
/**************************************************/
/******************** PUT CHAR *********************/
/**************************************************/

int putchar(int c)
{
    482e:	04 12       	push	r4		
    4830:	04 41       	mov	r1,	r4	
    4832:	24 53       	incd	r4		
    4834:	21 83       	decd	r1		
    4836:	84 4f fc ff 	mov	r15,	-4(r4)	;0xfffc(r4)
  return uart1_putchar(c);
    483a:	1f 44 fc ff 	mov	-4(r4),	r15	;0xfffc(r4)
    483e:	b0 12 fc 47 	call	#0x47fc	
}
    4842:	21 53       	incd	r1		
    4844:	34 41       	pop	r4		
    4846:	30 41       	ret			

00004848 <start_encrypt>:
/******************** END EXPE*********************/
/**************************************************/

void
start_encrypt()
{
    4848:	04 12       	push	r4		
    484a:	04 41       	mov	r1,	r4	
    484c:	24 53       	incd	r4		
  ;
}
    484e:	34 41       	pop	r4		
    4850:	30 41       	ret			

00004852 <start_decrypt>:
void
start_decrypt()
{
    4852:	04 12       	push	r4		
    4854:	04 41       	mov	r1,	r4	
    4856:	24 53       	incd	r4		
  ;
}
    4858:	34 41       	pop	r4		
    485a:	30 41       	ret			

0000485c <end_expe>:


void
end_expe()
{
    485c:	04 12       	push	r4		
    485e:	04 41       	mov	r1,	r4	
    4860:	24 53       	incd	r4		
  ;
}
    4862:	34 41       	pop	r4		
    4864:	30 41       	ret			

00004866 <memcpy>:
    4866:	0b 12       	push	r11		
    4868:	0a 12       	push	r10		
    486a:	09 12       	push	r9		
    486c:	08 12       	push	r8		
    486e:	07 12       	push	r7		
    4870:	0d 93       	tst	r13		
    4872:	70 24       	jz	$+226    	;abs 0x4954
    4874:	0f 9e       	cmp	r14,	r15	
    4876:	6e 24       	jz	$+222    	;abs 0x4954
    4878:	34 2c       	jc	$+106    	;abs 0x48e2
    487a:	0c 4e       	mov	r14,	r12	
    487c:	0c df       	bis	r15,	r12	
    487e:	1c f3       	and	#1,	r12	;r3 As==01
    4880:	1b 24       	jz	$+56     	;abs 0x48b8
    4882:	0c 4e       	mov	r14,	r12	
    4884:	0c ef       	xor	r15,	r12	
    4886:	1c f3       	and	#1,	r12	;r3 As==01
    4888:	07 20       	jnz	$+16     	;abs 0x4898
    488a:	2d 93       	cmp	#2,	r13	;r3 As==10
    488c:	07 28       	jnc	$+16     	;abs 0x489c
    488e:	0b 4e       	mov	r14,	r11	
    4890:	1b f3       	and	#1,	r11	;r3 As==01
    4892:	2c 43       	mov	#2,	r12	;r3 As==10
    4894:	0c 8b       	sub	r11,	r12	
    4896:	03 3c       	jmp	$+8      	;abs 0x489e
    4898:	0c 4d       	mov	r13,	r12	
    489a:	01 3c       	jmp	$+4      	;abs 0x489e
    489c:	1c 43       	mov	#1,	r12	;r3 As==01
    489e:	0d 8c       	sub	r12,	r13	
    48a0:	0a 4c       	mov	r12,	r10	
    48a2:	09 4e       	mov	r14,	r9	
    48a4:	0b 4f       	mov	r15,	r11	
    48a6:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    48aa:	1b 53       	inc	r11		
    48ac:	3a 53       	add	#-1,	r10	;r3 As==11
    48ae:	fb 23       	jnz	$-8      	;abs 0x48a6
    48b0:	0a 4f       	mov	r15,	r10	
    48b2:	0a 5c       	add	r12,	r10	
    48b4:	0e 5c       	add	r12,	r14	
    48b6:	01 3c       	jmp	$+4      	;abs 0x48ba
    48b8:	0a 4f       	mov	r15,	r10	
    48ba:	0b 4d       	mov	r13,	r11	
    48bc:	12 c3       	clrc			
    48be:	0b 10       	rrc	r11		
    48c0:	0b 24       	jz	$+24     	;abs 0x48d8
    48c2:	09 4b       	mov	r11,	r9	
    48c4:	08 4e       	mov	r14,	r8	
    48c6:	0c 4a       	mov	r10,	r12	
    48c8:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    48cc:	2c 53       	incd	r12		
    48ce:	39 53       	add	#-1,	r9	;r3 As==11
    48d0:	fb 23       	jnz	$-8      	;abs 0x48c8
    48d2:	0b 5b       	rla	r11		
    48d4:	0e 5b       	add	r11,	r14	
    48d6:	0a 5b       	add	r11,	r10	
    48d8:	1d f3       	and	#1,	r13	;r3 As==01
    48da:	3c 24       	jz	$+122    	;abs 0x4954
    48dc:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    48e0:	39 3c       	jmp	$+116    	;abs 0x4954
    48e2:	0e 5d       	add	r13,	r14	
    48e4:	0c 4f       	mov	r15,	r12	
    48e6:	0c 5d       	add	r13,	r12	
    48e8:	0b 4c       	mov	r12,	r11	
    48ea:	0b de       	bis	r14,	r11	
    48ec:	1b f3       	and	#1,	r11	;r3 As==01
    48ee:	1b 24       	jz	$+56     	;abs 0x4926
    48f0:	0b 4c       	mov	r12,	r11	
    48f2:	0b ee       	xor	r14,	r11	
    48f4:	1b f3       	and	#1,	r11	;r3 As==01
    48f6:	06 20       	jnz	$+14     	;abs 0x4904
    48f8:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    48fc:	03 28       	jnc	$+8      	;abs 0x4904
    48fe:	0b 4e       	mov	r14,	r11	
    4900:	1b f3       	and	#1,	r11	;r3 As==01
    4902:	01 3c       	jmp	$+4      	;abs 0x4906
    4904:	0b 4d       	mov	r13,	r11	
    4906:	0d 8b       	sub	r11,	r13	
    4908:	09 4e       	mov	r14,	r9	
    490a:	0a 4c       	mov	r12,	r10	
    490c:	08 4b       	mov	r11,	r8	
    490e:	08 8c       	sub	r12,	r8	
    4910:	3a 53       	add	#-1,	r10	;r3 As==11
    4912:	39 53       	add	#-1,	r9	;r3 As==11
    4914:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    4918:	07 4a       	mov	r10,	r7	
    491a:	07 58       	add	r8,	r7	
    491c:	f9 23       	jnz	$-12     	;abs 0x4910
    491e:	3b e3       	inv	r11		
    4920:	1b 53       	inc	r11		
    4922:	0c 5b       	add	r11,	r12	
    4924:	0e 5b       	add	r11,	r14	
    4926:	0b 4d       	mov	r13,	r11	
    4928:	12 c3       	clrc			
    492a:	0b 10       	rrc	r11		
    492c:	0e 24       	jz	$+30     	;abs 0x494a
    492e:	0a 4b       	mov	r11,	r10	
    4930:	08 4e       	mov	r14,	r8	
    4932:	09 4c       	mov	r12,	r9	
    4934:	28 83       	decd	r8		
    4936:	29 83       	decd	r9		
    4938:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    493c:	3a 53       	add	#-1,	r10	;r3 As==11
    493e:	fa 23       	jnz	$-10     	;abs 0x4934
    4940:	0a 8b       	sub	r11,	r10	
    4942:	0b 4a       	mov	r10,	r11	
    4944:	0b 5b       	rla	r11		
    4946:	0e 5b       	add	r11,	r14	
    4948:	0c 5b       	add	r11,	r12	
    494a:	1d f3       	and	#1,	r13	;r3 As==01
    494c:	03 24       	jz	$+8      	;abs 0x4954
    494e:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    4952:	ff ff 
    4954:	37 41       	pop	r7		
    4956:	38 41       	pop	r8		
    4958:	39 41       	pop	r9		
    495a:	3a 41       	pop	r10		
    495c:	3b 41       	pop	r11		
    495e:	30 41       	ret			

00004960 <_unexpected_>:
    4960:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	e8 40 e8 40 e8 40 e8 40 e8 40 e8 40 e8 40 e8 40     .@.@.@.@.@.@.@.@
    fff0:	e8 40 e8 40 e8 40 e8 40 e8 40 e8 40 e8 40 00 40     .@.@.@.@.@.@.@.@
